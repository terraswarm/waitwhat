<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="robot_status_hue" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="18">
        </property>
        <property name="anchor" class="ptolemy.data.expr.StringParameter" value="south">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Robot Status Indication - Hues">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[225.0, 25.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={0, 23, 1680, 1023}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1446, 913]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.617902978872316">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{219.02197535991132, 185.3984375}">
    </property>
    <property name="hueBulbIP" class="ptolemy.data.expr.StringParameter" value="192.168.11.117">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 0.0, 0.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:red" y="20">-S-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-55.0, 70.0]">
        </property>
    </property>
    <property name="hueUsername" class="ptolemy.data.expr.StringParameter" value="lab11in4908">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 0.0, 0.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:red" y="20">-S-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-55.0, 90.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.0,1.0}">
        </property>
        <property name="anchor" class="ptolemy.data.expr.StringParameter" value="south">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Receive status updates&#10;from main controller.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[10.0, 175.0]">
        </property>
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[35.0, 360.0]">
        </property>
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="false">
    </property>
    <property name="_defaultInferredWidthTo1" class="ptolemy.data.expr.Parameter" value="true">
    </property>
    <class name="lab11in" extends="ptolemy.actor.TypedCompositeActor">
        <display name="Status2Color"/>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[35.0, 295.0]">
        </property>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={240, 105, 1015, 634}, maximized=false}">
        </property>
        <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[781, 524]">
        </property>
        <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
        </property>
        <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{380.5, 252.0}">
        </property>
        <property name="bulbID" class="ptolemy.data.expr.Parameter" value="2">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[445.0, 100.0]">
            </property>
        </property>
        <property name="hueIP" class="ptolemy.data.expr.StringParameter" value="${hueBulbIP}">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 0.0, 0.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:red" y="20">-S-</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[445.0, 60.0]">
            </property>
        </property>
        <property name="hueUsername" class="ptolemy.data.expr.StringParameter" value="${hueUsername}">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 0.0, 0.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:red" y="20">-S-</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[445.0, 80.0]">
            </property>
        </property>
        <port name="status" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[100.0, 255.0]">
            </property>
        </port>
        <entity name="StringMatches" class="ptolemy.actor.lib.string.StringMatches">
            <display name="IDLE"/>
            <property name="pattern" class="ptolemy.actor.parameters.PortParameter" value="IDLE">
            </property>
            <property name="matchString" class="ptolemy.actor.parameters.PortParameter" value="IDLE">
            </property>
            <doc>Determine if a string matches a regular expression</doc>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{313.0, 238.0}">
            </property>
        </entity>
        <entity name="Const" class="ptolemy.actor.lib.Const">
            <property name="value" class="ptolemy.data.expr.Parameter" value="32001">
            </property>
            <doc>Create a constant sequence.</doc>
            <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
                </property>
                <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{518.0, 238.0}">
            </property>
        </entity>
        <entity name="TrueGate" class="ptolemy.actor.lib.logic.TrueGate">
            <property name="_location" class="ptolemy.kernel.util.Location" value="{418.0, 238.0}">
            </property>
        </entity>
        <entity name="StringMatches2" class="ptolemy.actor.lib.string.StringMatches">
            <display name="SERVING"/>
            <property name="pattern" class="ptolemy.actor.parameters.PortParameter" value="IDLE">
            </property>
            <property name="matchString" class="ptolemy.actor.parameters.PortParameter" value="SERVING">
            </property>
            <doc>Determine if a string matches a regular expression</doc>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{313.0, 298.0}">
            </property>
        </entity>
        <entity name="TrueGate2" class="ptolemy.actor.lib.logic.TrueGate">
            <property name="_location" class="ptolemy.kernel.util.Location" value="{418.0, 298.0}">
            </property>
        </entity>
        <entity name="Const2" class="ptolemy.actor.lib.Const">
            <property name="value" class="ptolemy.data.expr.Parameter" value="2000">
            </property>
            <doc>Create a constant sequence.</doc>
            <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
                </property>
                <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{518.0, 298.0}">
            </property>
        </entity>
        <entity name="Hue" class="org.terraswarm.accessor.JSAccessor">
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id: Hue.js 231 2015-07-31 22:45:12Z mpanj@seas.upenn.edu $$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   console.log(lights);&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/devices/Hue.js">
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="${hueIP}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="userName" class="ptolemy.data.expr.Parameter" value="${hueUsername}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="lightID" class="ptolemy.actor.parameters.PortParameter" value="bulbID">
            </property>
            <property name="brightness" class="ptolemy.actor.parameters.PortParameter" value="255">
            </property>
            <property name="hue" class="ptolemy.actor.parameters.PortParameter" value="32001.0">
            </property>
            <property name="saturation" class="ptolemy.actor.parameters.PortParameter" value="255">
            </property>
            <property name="on" class="ptolemy.actor.parameters.PortParameter" value="true">
            </property>
            <property name="transitionTime" class="ptolemy.actor.parameters.PortParameter" value="4">
            </property>
            <property name="trigger" class="ptolemy.actor.parameters.PortParameter" value="32001">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[710.0, 250.0]">
            </property>
            <port name="bridgeIPAddress" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="lightID" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="brightness" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="hue" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="saturation" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="on" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="transitionTime" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="trigger" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
                </property>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
        </entity>
        <entity name="StringMatches3" class="ptolemy.actor.lib.string.StringMatches">
            <display name="SPINNING"/>
            <property name="pattern" class="ptolemy.actor.parameters.PortParameter" value="IDLE">
            </property>
            <property name="matchString" class="ptolemy.actor.parameters.PortParameter" value="SPINNING">
            </property>
            <doc>Determine if a string matches a regular expression</doc>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[310.0, 355.0]">
            </property>
        </entity>
        <entity name="TrueGate3" class="ptolemy.actor.lib.logic.TrueGate">
            <property name="_location" class="ptolemy.kernel.util.Location" value="[420.0, 355.0]">
            </property>
        </entity>
        <entity name="Const3" class="ptolemy.actor.lib.Const">
            <property name="value" class="ptolemy.data.expr.Parameter" value="51345">
            </property>
            <doc>Create a constant sequence.</doc>
            <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
                </property>
                <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[520.0, 355.0]">
            </property>
        </entity>
        <relation name="relation" class="ptolemy.actor.TypedIORelation">
            <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
            </property>
            <vertex name="vertex1" value="{373.0, 238.0}">
            </vertex>
        </relation>
        <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation6" class="ptolemy.actor.TypedIORelation">
            <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
            </property>
            <vertex name="vertex1" value="[160.0, 255.0]">
            </vertex>
        </relation>
        <relation name="relation5" class="ptolemy.actor.TypedIORelation">
            <vertex name="vertex1" value="[605.0, 265.0]">
            </vertex>
        </relation>
        <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        </relation>
        <link port="status" relation="relation6"/>
        <link port="StringMatches.pattern" relation="relation6"/>
        <link port="StringMatches.output" relation="relation"/>
        <link port="Const.output" relation="relation5"/>
        <link port="Const.trigger" relation="relation2"/>
        <link port="TrueGate.input" relation="relation"/>
        <link port="TrueGate.output" relation="relation2"/>
        <link port="StringMatches2.pattern" relation="relation6"/>
        <link port="StringMatches2.output" relation="relation3"/>
        <link port="TrueGate2.input" relation="relation3"/>
        <link port="TrueGate2.output" relation="relation4"/>
        <link port="Const2.output" relation="relation5"/>
        <link port="Const2.trigger" relation="relation4"/>
        <link port="Hue.hue" relation="relation5"/>
        <link port="Hue.trigger" relation="relation5"/>
        <link port="StringMatches3.pattern" relation="relation6"/>
        <link port="StringMatches3.output" relation="relation7"/>
        <link port="TrueGate3.input" relation="relation7"/>
        <link port="TrueGate3.output" relation="relation8"/>
        <link port="Const3.output" relation="relation5"/>
        <link port="Const3.trigger" relation="relation8"/>
    </class>
    <entity name="OpFilter" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;  });&#10;  output('Output', {&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpFilter.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="robotid">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="value" class="ptolemy.data.expr.Parameter" value="0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[227.5, 115.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpStripString" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Strips out a certain key's value from an object as a string.&#10; *&#10; *  @accessor OpStripString&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input');&#10;  output('Output', {&#10;    type: 'string'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key to extract the value from&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;  key = getParameter('key');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key)) {&#10;    send('Output', ''+i[key]);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpStripString.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="status">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[342.5, 115.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpFilter2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;  });&#10;  output('Output', {&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpFilter.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="robotid">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="value" class="ptolemy.data.expr.Parameter" value="1">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[227.5, 180.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpStripString2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Strips out a certain key's value from an object as a string.&#10; *&#10; *  @accessor OpStripString&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input');&#10;  output('Output', {&#10;    type: 'string'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key to extract the value from&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;  key = getParameter('key');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key)) {&#10;    send('Output', ''+i[key]);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpStripString.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="status">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[342.5, 180.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpFilter3" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;  });&#10;  output('Output', {&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpFilter.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="robotid">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="value" class="ptolemy.data.expr.Parameter" value="2">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[227.5, 245.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpStripString3" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Strips out a certain key's value from an object as a string.&#10; *&#10; *  @accessor OpStripString&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input');&#10;  output('Output', {&#10;    type: 'string'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key to extract the value from&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;  key = getParameter('key');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key)) {&#10;    send('Output', ''+i[key]);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpStripString.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="status">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[342.5, 245.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpStrip" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Strips out a certain key's value from an object.&#10; *&#10; *  @accessor OpStrip&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input');&#10;  output('Output');&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key to extract the value from&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;  key = getParameter('key');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key)) {&#10;    send('Output', i[key]);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpStrip.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[80.0, 210.0]">
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="message">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="WebSocketClient" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a web socket at&#10; *  the specified host and port. In `initialize()`, it&#10; *  begins connecting to the web socket server.&#10; *  Once the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *  If connection is not established immediately, the accessor will attempt to&#10; *  reconnect (numberOfRetries) times at an interval of (reconnectInterval)&#10; *&#10; *  Whenever an input is received on the `toSend`&#10; *  input, the message is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded. If messages are queued and `throttleFactor` is non-zero, then&#10; *  whenever a message is queued to be later sent, the accessor will stall&#10; *  by a number of milliseconds given by the queue size times the throttleFactor.&#10; *  The longer the queue, the longer the stall. Note that this will likely block&#10; *  the host from executing, so this feature should be used with caution.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `'received'` output. The maxFrameSize parameter limits the size&#10; *  of received messages, and any attempt to send to this client a larger message&#10; *  will cause an error.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *  &#10; *  If the connection is dropped midway, the client will attempt to reconnect if &#10; *  (reconnectOnClose) is true. This does not apply when the accessor wraps up. &#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *  &#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *  &#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. See `RosPublisher.js` for an example.&#10; *&#10; *  This accessor requires the 'webSocket' module.&#10; *&#10; *  @accessor net/WebSocketClient&#10; *  @parameter {string} server The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port that the web socket listens to. Defaults to 8080.&#10; *  @parameter {string} receiveType The MIME type for incoming messages, which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages, which defaults to 'application/json'.&#10; *  @parameter {int} connectTimeout The time in milliseconds to wait before giving up on a connection (default is 60000).&#10; *  @parameter {int} maxFrameSize The maximum frame size for a received message (default is 65536).&#10; *  @parameter {int} numberOfRetries The number of times to retry if a connection fails. Defaults to 5.&#10; *  @parameter {int} timeBetweenRetries The time between retries in milliseconds. Defaults to 100.&#10; *  @parameter {boolean} reconnectOnClose The option of whether or not to reconnect when disconnected.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then any messages received on `toSend` before the socket is open will be discarded. This defaults to false.&#10; *  @parameter {int} throttleFactor If non-zero, specifies a time (in milliseconds) to stall when a message is queued because the socket is not yet open. The time of the stall will be the queue size (after adding the message) times the throttleFactor. This defaults to 0.&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *  @author Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber&#10; *  @version $$Id: WebSocketClient.js 284 2015-08-30 14:51:19Z eal $$&#10; */&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;&quot;use strict&quot;;&#10;/*global addInputHandler, error, get, getParameter, input, onClose, output, parameter, removeInputHandler, send */&#10;&#10;var WebSocket = require('webSocket');&#10;var client = null;&#10;var inputHandle = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    parameter('server', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 8080&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'application/json',&#10;        options : WebSocket.supportedReceiveTypes()&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'application/json',&#10;        options : WebSocket.supportedSendTypes()&#10;    });&#10;    parameter('connectTimeout', {&#10;        value: 60000, &#10;        type: &quot;int&quot; &#10;    });&#10;    parameter('maxFrameSize', {&#10;        value: 65536, &#10;        type: &quot;int&quot; &#10;    });&#10;    parameter('numberOfRetries', {&#10;        type : 'int',&#10;        value : 5&#10;    });&#10;    parameter('timeBetweenRetries', {&#10;        type : 'int',&#10;        value : 100&#10;    });&#10;    parameter('reconnectOnClose', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('throttleFactor', {&#10;        type : 'int',&#10;        value : 0&#10;    });&#10;    input('toSend');&#10;    output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    output('received');&#10;};&#10;&#10;/** Initializes accessor by attaching functions to inputs. */&#10;exports.initialize = function () {&#10;&#10;    //record the object that calls it (could be a derived accessor). &#10;    var callObj = this;&#10;&#10;    client = new WebSocket.Client(&#10;        {&#10;            'host' : getParameter('server'),&#10;            'port' : getParameter('port'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'sendType' : getParameter('sendType'),&#10;            'connectTimeout' : getParameter('connectTimeout'),&#10;            'maxFrameSize' : getParameter('maxFrameSize'),&#10;            'numberOfRetries' : getParameter('numberOfRetries'),&#10;            'timeBetweenRetries' : getParameter('timeBetweenRetries'),&#10;            'discardMessagesBeforeOpen' : getParameter('discardMessagesBeforeOpen'),&#10;            'throttleFactor' : getParameter('throttleFactor')&#10;        }&#10;    );&#10;&#10;    client.on('open', this.onOpen);&#10;    client.on('message', this.onMessage);&#10;&#10;    //bind onClose() to caller's object, &#10;    //so initialize() of caller's object is called if reconnect is true.&#10;    client.on('close', onClose.bind(callObj));&#10;    client.on('error', function (message) {&#10;        error(message);&#10;    });&#10;    //only execute once, and not when trying to reconnect. &#10;    if (inputHandle === null) {&#10;        inputHandle = addInputHandler('toSend', this.toSendInputHandler);&#10;    }&#10;};&#10;&#10;/** Handles input on 'toSend'. */&#10;exports.toSendInputHandler = function () {&#10;    exports.sendToWebSocket(get('toSend'));&#10;};&#10;&#10;/** Sends JSON data to the web socket. */&#10;exports.sendToWebSocket = function (data) {&#10;    if (client !== null) {&#10;        client.send(data);&#10;        console.log(&quot;Sending to web socket: &quot; + data);&#10;    } else {&#10;        console.log(&quot;Client is null. Could not send message: &quot; + data);&#10;    }&#10;};&#10;&#10;/** Executes once  web socket establishes a connection.&#10; *   Sets 'connected' output to true.&#10; */&#10;exports.onOpen = function () {&#10;    console.log('Status: Connection established');&#10;    send('connected', true);&#10;};&#10;&#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;    console.log('Status: Connection closed: ' + message);&#10;    if (inputHandle) {&#10;        // wrapup() has not been called.&#10;        // Probably the server closed the connection.&#10;        send('connected', false);&#10;        // Reconnect if reconnectOnClose is true.&#10;        if (getParameter('reconnectOnClose')) {&#10;            // Use 'this' rather than 'export' so initialize() can be overridden.&#10;            this.initialize();&#10;        } else {&#10;            // Not set to reconnect on close.&#10;            // Close and unregister everything.&#10;            client.removeAllListeners('open');&#10;            client.removeAllListeners('message');&#10;            client.removeAllListeners('close');&#10;            client = null;&#10;        }&#10;    }&#10;}&#10;&#10;/** Send the message received from web socket to the 'received' output. */&#10;exports.onMessage = function (message) {&#10;    send('received', message);&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (inputHandle !== null) {&#10;        removeInputHandler(inputHandle);&#10;        inputHandle = null;&#10;    }&#10;    if (client) {&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        client = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-30.0, 210.0]">
        </property>
        <property name="server" class="ptolemy.data.expr.Parameter" value="192.168.11.108">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8089">
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="connectTimeout" class="ptolemy.data.expr.Parameter" value="60000">
        </property>
        <property name="maxFrameSize" class="ptolemy.data.expr.Parameter" value="65536">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a web socket at&#10; the specified host and port. In &lt;code&gt;initialize()&lt;/code&gt;, it&#10; begins connecting to the web socket server.&#10; Once the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output.&#10; If connection is not established immediately, the accessor will attempt to&#10; reconnect (numberOfRetries) times at an interval of (reconnectInterval)&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt;&#10; input, the message is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when the socket opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded. If messages are queued and &lt;code&gt;throttleFactor&lt;/code&gt; is non-zero, then&#10; whenever a message is queued to be later sent, the accessor will stall&#10; by a number of milliseconds given by the queue size times the throttleFactor.&#10; The longer the queue, the longer the stall. Note that this will likely block&#10; the host from executing, so this feature should be used with caution.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;'received'&lt;/code&gt; output. The maxFrameSize parameter limits the size&#10; of received messages, and any attempt to send to this client a larger message&#10; will cause an error.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; connection.&lt;/p&gt;&#10;&lt;p&gt; If the connection is dropped midway, the client will attempt to reconnect if &#10; (reconnectOnClose) is true. This does not apply when the accessor wraps up. &lt;/p&gt;&#10;&lt;p&gt; The default type for both sending and receiving&#10; is 'application/json', which allows sending and receiving anything that has&#10; a string representation in JSON. The types supported by this implementation&#10; include at least:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;application/json&lt;/strong&gt;: The send() function uses JSON.stringify() and sends the&#10;result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10;and if the parsing fails, will be provided as a string interpretation of the byte&#10;stream.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;text/*&lt;/strong&gt;: Any text type is sent as a string encoded in UTF-8.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;image/x&lt;/strong&gt;: Where &lt;strong&gt;x&lt;/strong&gt; is one of &lt;strong&gt;json&lt;/strong&gt;, &lt;strong&gt;png&lt;/strong&gt;, &lt;strong&gt;gif&lt;/strong&gt;,&#10;and more.&#10;In this case, the data passed to send() is assumed to be an image, as encoded&#10;on the host, and the image will be encoded as a byte stream in the specified&#10;format before sending.  A received byte stream will be decoded as an image,&#10;if possible.&lt;/p&gt;&#10;&lt;p&gt;When a model with an instance of this accessor stops executing, there&#10;are two mechanisms by which data in transit can be lost. In both cases, warning&#10;messages or error messages will be issued to the host to be displayed or otherwise&#10;handled as the host sees fit.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/p&gt;&#10;&lt;p&gt;The server might similarly lose messages by the same two mechanisms occurring&#10;on the server side. In that case, messages will presumably be displayed on the&#10;server side.&lt;/p&gt;&#10;&lt;p&gt;Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10;to customize what is sent. See &lt;code&gt;RosPublisher.js&lt;/code&gt; for an example.&lt;/p&gt;&#10;&lt;p&gt;This accessor requires the 'webSocket' module.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$Id: WebSocketClient.js 284 2015-08-30 14:51:19Z eal $">
            </property>
            <property name="server (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The port that the web socket listens to. Defaults to 8080.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The MIME type for incoming messages, which defaults to 'application/json'.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The MIME type for outgoing messages, which defaults to 'application/json'.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The time in milliseconds to wait before giving up on a connection (default is 60000).">
            </property>
            <property name="maxFrameSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The maximum frame size for a received message (default is 65536).">
            </property>
            <property name="numberOfRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The number of times to retry if a connection fails. Defaults to 5.">
            </property>
            <property name="timeBetweenRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The time between retries in milliseconds. Defaults to 100.">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) The option of whether or not to reconnect when disconnected.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) If true, then any messages received on `toSend` before the socket is open will be discarded. This defaults to false.">
            </property>
            <property name="throttleFactor (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) If non-zero, specifies a time (in milliseconds) to stall when a message is queued because the socket is not yet open. The time of the stall will be the queue size (after adding the message) times the throttleFactor. This defaults to 0.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="undefined The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="undefined The data received from the web socket server.">
            </property>
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="OpFilter4" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;  });&#10;  output('Output', {&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpFilter.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="robotid">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="value" class="ptolemy.data.expr.Parameter" value="3">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[227.5, 310.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="OpStripString4" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Strips out a certain key's value from an object as a string.&#10; *&#10; *  @accessor OpStripString&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input');&#10;  output('Output', {&#10;    type: 'string'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key to extract the value from&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;  key = getParameter('key');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key)) {&#10;    send('Output', ''+i[key]);&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/OpStripString.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="key" class="ptolemy.data.expr.Parameter" value="status">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[342.5, 310.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
    </entity>
    <entity name="InstanceOflab11in" class="lab11in">
        <display name="Status2Color"/>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[457.5, 115.0]">
        </property>
        <property name="bulbID" class="ptolemy.data.expr.Parameter" value="1">
        </property>
        <entity name="Hue" class="org.terraswarm.accessor.JSAccessor">
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id: Hue.js 231 2015-07-31 22:45:12Z mpanj@seas.upenn.edu $$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   console.log(lights);&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
            </property>
            <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="${hueIP}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="userName" class="ptolemy.data.expr.Parameter" value="${hueUsername}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
        </entity>
    </entity>
    <entity name="InstanceOflab11in2" class="lab11in">
        <display name="Status2Color"/>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[457.5, 180.0]">
        </property>
        <property name="bulbID" class="ptolemy.data.expr.Parameter" value="2">
        </property>
        <entity name="Hue" class="org.terraswarm.accessor.JSAccessor">
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id: Hue.js 231 2015-07-31 22:45:12Z mpanj@seas.upenn.edu $$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   console.log(lights);&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
            </property>
            <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="${hueIP}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="userName" class="ptolemy.data.expr.Parameter" value="${hueUsername}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
        </entity>
    </entity>
    <entity name="InstanceOflab11in3" class="lab11in">
        <display name="Status2Color"/>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[457.5, 245.0]">
        </property>
        <property name="bulbID" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <entity name="Hue" class="org.terraswarm.accessor.JSAccessor">
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id: Hue.js 231 2015-07-31 22:45:12Z mpanj@seas.upenn.edu $$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   console.log(lights);&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
            </property>
            <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="${hueIP}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="userName" class="ptolemy.data.expr.Parameter" value="${hueUsername}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
        </entity>
    </entity>
    <entity name="InstanceOflab11in4" class="lab11in">
        <display name="Status2Color"/>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[457.5, 310.0]">
        </property>
        <property name="bulbID" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <entity name="Hue" class="org.terraswarm.accessor.JSAccessor">
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id: Hue.js 231 2015-07-31 22:45:12Z mpanj@seas.upenn.edu $$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   console.log(lights);&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
            </property>
            <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="${hueIP}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="userName" class="ptolemy.data.expr.Parameter" value="${hueUsername}">
                <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
        </entity>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[130.0, 210.0]">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="OpFilter.Input" relation="relation2"/>
    <link port="OpFilter.Output" relation="relation4"/>
    <link port="OpStripString.Input" relation="relation4"/>
    <link port="OpStripString.Output" relation="relation7"/>
    <link port="OpFilter2.Input" relation="relation2"/>
    <link port="OpFilter2.Output" relation="relation3"/>
    <link port="OpStripString2.Input" relation="relation3"/>
    <link port="OpStripString2.Output" relation="relation8"/>
    <link port="OpFilter3.Input" relation="relation2"/>
    <link port="OpFilter3.Output" relation="relation5"/>
    <link port="OpStripString3.Input" relation="relation5"/>
    <link port="OpStripString3.Output" relation="relation9"/>
    <link port="OpStrip.Input" relation="relation"/>
    <link port="OpStrip.Output" relation="relation2"/>
    <link port="WebSocketClient.received" relation="relation"/>
    <link port="OpFilter4.Input" relation="relation2"/>
    <link port="OpFilter4.Output" relation="relation6"/>
    <link port="OpStripString4.Input" relation="relation6"/>
    <link port="OpStripString4.Output" relation="relation10"/>
    <link port="InstanceOflab11in.status" relation="relation7"/>
    <link port="InstanceOflab11in2.status" relation="relation8"/>
    <link port="InstanceOflab11in3.status" relation="relation9"/>
    <link port="InstanceOflab11in4.status" relation="relation10"/>
</entity>
