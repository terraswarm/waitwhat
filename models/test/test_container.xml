<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="test_container" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[95.0, 95.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={0, 23, 1680, 1023}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1446, 913]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="0.9745710589383046">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{579.734375, 365.46237922179654}">
    </property>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="3.0">
        </property>
        <doc>Create periodic timed events.</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-120.0, 215.0]">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="multiport"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="period" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="start" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="stop" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="StringConst2" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="F967525B-2A41-4261-A1E4-2C3EDBBD33AF">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[105.0, 215.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
    </entity>
    <entity name="CoordinateLinearTransform" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Shifts X,Y,Z coordinates&#10; *&#10; *  @accessor CoordinateLinearTransform&#10; *&#10;*/&#10;&#10;var shifts = {&#10;  X: 0,&#10;  Y: 0,&#10;  Z: 0&#10;};&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;  });&#10;  output('Output', {&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  parameter('Xshift', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;  parameter('Yshift', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;  parameter('Zshift', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  shifts.X = getParameter('Xshift');&#10;  shifts.Y = getParameter('Yshift');&#10;  shifts.Z = getParameter('Zshift');&#10;}&#10;&#10;var Input_in = function () {&#10;  var v = get('Input');&#10;&#10;  var axes = ['X', 'Y', 'Z'];&#10;  for (i=0; i&lt;axes.length; i++) {&#10;    var axis = axes[i];&#10;&#10;    if (typeof v === 'object' &amp;&amp; axis in v &amp;&amp; v.hasOwnProperty(axis)) {&#10;      v[axis] += shifts[axis];&#10;    }&#10;  }&#10;&#10;  send('Output', v);&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/CoordinateLinearTransform.js">
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-2.0, 0.0]">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="70.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="47.0">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0,1.0,1.0,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="2">
                </property>
                <property name="_location" class="ptolemy.kernel.util.Location" value="{28.0, -18.0}">
                </property>
            </property>
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={386, 282, 934, 634}, maximized=false}">
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
            <property name="Arrow" class="ptolemy.vergil.kernel.attributes.ArrowAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[6.0, -21.0]">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="1.5">
                </property>
                <property name="lineColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
                </property>
                <property name="x" class="ptolemy.data.expr.Parameter" value="0">
                </property>
                <property name="y" class="ptolemy.data.expr.Parameter" value="20">
                </property>
                <property name="arrowLength" class="ptolemy.data.expr.Parameter" value="2.0">
                </property>
                <property name="arrowWidth" class="ptolemy.data.expr.Parameter" value="5.0">
                </property>
            </property>
            <property name="Arrow2" class="ptolemy.vergil.kernel.attributes.ArrowAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[28.0, 2.0]">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="1.5">
                </property>
                <property name="lineColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
                </property>
                <property name="x" class="ptolemy.data.expr.Parameter" value="-25">
                </property>
                <property name="y" class="ptolemy.data.expr.Parameter" value="0">
                </property>
                <property name="arrowLength" class="ptolemy.data.expr.Parameter" value="2.0">
                </property>
                <property name="arrowWidth" class="ptolemy.data.expr.Parameter" value="5.0">
                </property>
            </property>
            <property name="ParameterValue" class="ptolemy.vergil.kernel.attributes.AttributeValueAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.4,0.4,0.4,1.0}">
                </property>
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="Xshift">
                </property>
                <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="6">
                </property>
                <property name="_location" class="ptolemy.kernel.util.Location" value="[2.0, 3.0]">
                </property>
            </property>
            <property name="ParameterValue2" class="ptolemy.vergil.kernel.attributes.AttributeValueAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.4,0.4,0.4,1.0}">
                </property>
                <property name="anchor" class="ptolemy.data.expr.StringParameter" value="east">
                </property>
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="Yshift">
                </property>
                <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="6">
                </property>
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-1.0, -8.0]">
                </property>
            </property>
        </property>
        <property name="Xshift" class="ptolemy.data.expr.Parameter" value=".2">
        </property>
        <property name="Yshift" class="ptolemy.data.expr.Parameter" value="4.146">
        </property>
        <property name="Zshift" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[530.0, 215.0]">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="multiport"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="FakeLocationStream2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Generate a stream of made up location data.&#10; *&#10; *  Outputs an object that looks like:&#10; *&#10; *      {&#10; *        id: &lt;unique id per thing being localized&gt;&#10; *        X:  &lt;x coordinate&gt;&#10; *        Y:  &lt;x coordinate&gt;&#10; *        Z:  &lt;x coordinate&gt;&#10; *      }&#10; *&#10; *  @accessor FakeLocationStream&#10; *&#10;*/&#10;&#10;// Which ID we should be generating location data for&#10;var current_id;&#10;&#10;// Last location&#10;var x;&#10;var y;&#10;var z;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('ID', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;1&quot;&#10;  });&#10;  output('Location', {&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // How often to generate a new location value in seconds&#10;  parameter('Period', {&#10;    value: 1,&#10;    type: 'number'&#10;  });&#10;&#10;  // Bounds of generated locations in meters&#10;  parameter('MinX', {value: 0, type: 'number'});&#10;  parameter('MaxX', {value: 10, type: 'number'});&#10;  parameter('MinY', {value: 0, type: 'number'});&#10;  parameter('MaxY', {value: 10, type: 'number'});&#10;  parameter('MinZ', {value: 1, type: 'number'});&#10;  parameter('MaxZ', {value: 2, type: 'number'});&#10;&#10;  // How much any one parameter can vary between updates&#10;  parameter('MaxVariance', {value: 0.2, type: 'number'});&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('ID', ID_in);&#10;&#10;  current_id = get('ID');&#10;  x = getParameter('MinX');&#10;  y = getParameter('MinY');&#10;  z = getParameter('MinZ');&#10;&#10;  // Use the period parameter to setup the loop that generates fake&#10;  // location data.&#10;  setInterval(update_location, getParameter('Period')*1000);&#10;}&#10;&#10;function getRandomArbitrary (min, max) {&#10;  return Math.random() * (max - min) + min;&#10;}&#10;&#10;function getRandomInt (min, max) {&#10;  return Math.floor(Math.random() * (max - min)) + min;&#10;}&#10;&#10;// Generates a new location value and sends to output based on parameters set&#10;function update_location () {&#10;&#10;  var j = getParameter('MaxVariance');&#10;  var alter = getRandomArbitrary(j/2, j);&#10;  var neg = getRandomInt(1, 3);&#10;  if (neg == 1) {&#10;    alter *= -1;&#10;  }&#10;&#10;  // Choose which axis to change on this iteration&#10;  var whichone = getRandomInt(0, 3);&#10;&#10;  if (whichone == 0) {&#10;    // ALTER X&#10;    var new_x = x + alter;&#10;    if (new_x &lt; getParameter('MinX')) new_x = getParameter('MinX');&#10;    if (new_x &gt; getParameter('MaxX')) new_x = getParameter('MaxX');&#10;    x = new_x;&#10;  &#10;  } else if (whichone == 1) {&#10;    // ALTER Y&#10;    var new_y = y + alter;&#10;    if (new_y &lt; getParameter('MinY')) new_y = getParameter('MinY');&#10;    if (new_y &gt; getParameter('MaxY')) new_y = getParameter('MaxY');&#10;    y = new_y;&#10;&#10;  } else if (whichone == 2) {&#10;    // ALTER Z&#10;    var new_z = z + alter;&#10;    if (new_z &lt; getParameter('MinZ')) new_z = getParameter('MinZ');&#10;    if (new_z &gt; getParameter('MaxZ')) new_z = getParameter('MaxZ');&#10;    z = new_z;&#10;&#10;  }&#10;&#10;  var loc = {&#10;    id: current_id,&#10;    X: x,&#10;    Y: y,&#10;    Z: z&#10;  };&#10;&#10;  send('Location', loc);&#10;&#10;}&#10;&#10;&#10;var ID_in  = function () {&#10;  current_id = get('ID');&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/FakeLocationStream.js">
        </property>
        <property name="ID" class="ptolemy.actor.parameters.PortParameter" value="F967525B-2A41-4261-A1E4-2C3EDBBD33AF">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="Period" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MinX" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxX" class="ptolemy.data.expr.Parameter" value="10">
        </property>
        <property name="MinY" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxY" class="ptolemy.data.expr.Parameter" value="15">
        </property>
        <property name="MinZ" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MaxZ" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="MaxVariance" class="ptolemy.data.expr.Parameter" value="3">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[310.0, 215.0]">
        </property>
        <port name="ID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Command2Pose" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Create a MoveActionGoal ROS message from an X,Y,Z coordinate.&#10; *&#10; *  @accessor MoveActionGoalMessage&#10; *&#10;*/&#10;&#10;// Set default&#10;var last_location = {&#10;  position: {&#10;    x: 0,&#10;    y: 0,&#10;    z: 0&#10;  },&#10;  orientation: {&#10;    x: 0,&#10;    y: 0,&#10;    z: 0,&#10;    w: 1&#10;  }&#10;};&#10;&#10;// Variables for spin&#10;var timer = null;&#10;var steps;&#10;var last_location_spin;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  // Input command of what the robot should do.&#10;  //  {&#10;  //    command: Go|Spin&#10;  //    X: Y: Z:   // only if Go command&#10;  //  }&#10;  input('Command');&#10;&#10;  // Current location of the robot&#10;  input('Location');&#10;&#10;  // Direct the robot&#10;  output('Pose');&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Command', Command_in);&#10;  addInputHandler('Location', Location_in);&#10;}&#10;&#10;var QUANTERION_THIRD = {&#10;  x: 0,&#10;  y: 0,&#10;  z: 0.894427191,&#10;  w: 0.4472135955&#10;};&#10;&#10;function multiply_quanterions (q1, q2) {&#10;  ret = {&#10;    x:  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x,&#10;    y: -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y,&#10;    z:  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z,&#10;    w: -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w&#10;  }&#10;  return ret;&#10;}&#10;&#10;function normalize_quaternion (q) {&#10;  var n = Math.sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);&#10;  var ret = {&#10;    x: q.x/n,&#10;    y: q.y/n,&#10;    z: q.z/n,&#10;    w: q.w/n,&#10;  }&#10;  return ret;&#10;}&#10;&#10;&#10;var Command_in = function () {&#10;  // Upon new command we need to stop any internal timers&#10;  if (timer != null) {&#10;    clearInterval(timer);&#10;    // workaround incase this doesnt work&#10;    steps = 100;&#10;    timer = null;&#10;  }&#10;&#10;  // Now parse the incoming command&#10;  var cmd = get('Command');&#10;&#10;  if (cmd.command == 'Go') {&#10;    // Send the robot to the given location&#10;  &#10;    var x = cmd.X || 0; &#10;    var y = cmd.Y || 0; &#10;    var z = cmd.Z || 0; &#10;&#10;    out = {&#10;      'position': {&#10;        'x': x,&#10;        'y': y,&#10;        'z': 0.0&#10;      },&#10;      'orientation': last_location.orientation&#10;    }&#10;    send('Pose', out);&#10;&#10;  } else if (cmd.command == 'Spin') {&#10;    // Start the spin&#10;    steps = 0;&#10;&#10;    function set_orientation () {&#10;      if (steps == 0) {&#10;        // Save where we are at the start&#10;        last_location_spin = last_location;&#10;      }&#10;&#10;      if (steps &lt; 6) {&#10;        // Rotate by 1/3 of a circle&#10;        var rotated = multiply_quanterions(last_location_spin.orientation, QUANTERION_THIRD);&#10;        rotated = normalize_quaternion(rotated);&#10;        last_location_spin.orientation = rotated;&#10;&#10;        send('Pose', last_location_spin);&#10;      }&#10;&#10;      steps++;&#10;      if (steps &gt;= 24) {&#10;        clearInterval(timer);&#10;      }&#10;    }&#10;&#10;    if (timer == null) {&#10;      timer = setInterval(set_orientation, 5000);&#10;      set_orientation();&#10;    }&#10;    &#10;  }&#10;}&#10;&#10;// Save the last location&#10;var Location_in = function () {&#10;  last_location = get('Location');&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/Command2Pose.js">
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="0.5, 0.0">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="57.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="30.0">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.0,0.6,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="24">
                </property>
                <property name="bold" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="italic" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="text" class="ptolemy.kernel.util.StringAttribute" value="C2P">
                </property>
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[875.0, 215.0]">
        </property>
        <port name="Command" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_cardinal" class="ptolemy.kernel.util.StringAttribute" value="NORTH">
            </property>
        </port>
        <port name="Pose" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Location2Command" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Create a Command from a location. Make a Go command.&#10; *&#10; *  @accessor Location2Command&#10; *&#10;*/&#10;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Location');&#10;  output('Command');&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Location', Location_in);&#10;}&#10;&#10;// Add command&#10;var Location_in = function () {&#10;  var l = get('Location');&#10;  l.command = 'Go';&#10;  send('Command', l);&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/Location2Command.js">
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="3.552713678800501E-15, 0.0">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="54.00000000000001">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="30.0">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.0,0.6,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="24">
                </property>
                <property name="bold" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="italic" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="text" class="ptolemy.kernel.util.StringAttribute" value="L2C">
                </property>
            </property>
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={323, 258, 934, 634}, maximized=false}">
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[710.0, 215.0]">
        </property>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Command" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Container" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Contain the robot!&#10; *&#10; *&#10; *  @accessor Container&#10; *&#10;*/&#10;&#10;var boundary = [];&#10;var boundary_single = [];&#10;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('PoseIn');&#10;  output('PoseOut');&#10;&#10;  parameter('Boundary', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  var points = getParameter('Boundary').split(',');&#10;  for (var i=1; i&lt;points.length; i+=2) {&#10;    var x = parseFloat(points[i-1]);&#10;    var y = parseFloat(points[i]);&#10;    boundary_single.push(x);&#10;    boundary_single.push(y);&#10;    boundary.push([x, y]);&#10;  }&#10;&#10;  addInputHandler('PoseIn', PoseIn_In);&#10;}&#10;&#10;function checkInside (point) {&#10;    // ray-casting algorithm based on&#10;    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html&#10;    var vs = boundary;&#10;    var x = point[0], y = point[1];&#10;    &#10;    var inside = false;&#10;    for (var i = 0, j = vs.length - 1; i &lt; vs.length; j = i++) {&#10;        var xi = vs[i][0], yi = vs[i][1];&#10;        var xj = vs[j][0], yj = vs[j][1];&#10;        &#10;        var intersect = ((yi &gt; y) != (yj &gt; y))&#10;            &amp;&amp; (x &lt; (xj - xi) * (y - yi) / (yj - yi) + xi);&#10;        if (intersect) inside = !inside;&#10;    }&#10;    &#10;    return inside;&#10;};&#10;&#10;function offset_point (sx, sy, ex, ey) {&#10;  var a = sx - ex;&#10;  var b = sy - ey;&#10;&#10;  var bp = Math.sqrt((0.3*0.3)/(1+((a*a)/(b*b))));&#10;  var ap = (a*bp)/b;&#10;&#10;  var new_x = sx - ap;&#10;  var new_y = sy - bp;&#10;  return [new_x, new_y];&#10;}&#10;&#10;var PoseIn_In = function () {&#10;  var p = get('PoseIn');&#10;  var x = p.position.x;&#10;  var y = p.position.y;&#10;&#10;  // Check if the point is inside&#10;  if (checkInside([x, y])) {&#10;    // Woo! Good to go, send this along&#10;    send('PoseOut', p);&#10;  } else {&#10;    console.log('Point is outside ' + x + ' y: ' + y);&#10;&#10;    // Outside, get closest point&#10;    var closest = PolyK.ClosestEdge(boundary_single, x, y);&#10;    var new_x = closest.point.x;&#10;    var new_y = closest.point.y;&#10;&#10;    // Move 30cm beyond that so we don't go right to the wall&#10;    var shifted = offset_point(x, y, new_x, new_y);&#10;&#10;&#10;    console.log(closest);&#10;    console.log(shifted);&#10;    p.position.x = shifted[0];&#10;    p.position.y = shifted[1];&#10;    send('PoseOut', p);&#10;  }&#10;&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;  /*&#10;    PolyK library&#10;    url: http://polyk.ivank.net&#10;    Released under MIT licence.&#10;    &#10;    Copyright (c) 2012 - 2014 Ivan Kuckir&#10;&#10;    Permission is hereby granted, free of charge, to any person&#10;    obtaining a copy of this software and associated documentation&#10;    files (the &quot;Software&quot;), to deal in the Software without&#10;    restriction, including without limitation the rights to use,&#10;    copy, modify, merge, publish, distribute, sublicense, and/or sell&#10;    copies of the Software, and to permit persons to whom the&#10;    Software is furnished to do so, subject to the following&#10;    conditions:&#10;&#10;    The above copyright notice and this permission notice shall be&#10;    included in all copies or substantial portions of the Software.&#10;&#10;    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,&#10;    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES&#10;    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND&#10;    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT&#10;    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,&#10;    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING&#10;    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR&#10;    OTHER DEALINGS IN THE SOFTWARE.&#10;    &#10;    19. 5. 2014 - Problem with slicing fixed.&#10;  */&#10;&#10;  var PolyK = {};&#10;  &#10;  /*&#10;    Is Polygon self-intersecting?&#10;    &#10;    O(n^2)&#10;  */&#10;  &#10;  PolyK.IsSimple = function(p)&#10;  {&#10;    var n = p.length&gt;&gt;1;&#10;    if(n&lt;4) return true;&#10;    var a1 = new PolyK._P(), a2 = new PolyK._P();&#10;    var b1 = new PolyK._P(), b2 = new PolyK._P();&#10;    var c = new PolyK._P();&#10;    &#10;    for(var i=0; i&lt;n; i++)&#10;    {&#10;      a1.x = p[2*i  ];&#10;      a1.y = p[2*i+1];&#10;      if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }&#10;      else    { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }&#10;      &#10;      for(var j=0; j&lt;n; j++)&#10;      {&#10;        if(Math.abs(i-j) &lt; 2) continue;&#10;        if(j==n-1 &amp;&amp; i==0) continue;&#10;        if(i==n-1 &amp;&amp; j==0) continue;&#10;        &#10;        b1.x = p[2*j  ];&#10;        b1.y = p[2*j+1];&#10;        if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }&#10;        else    { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }&#10;        &#10;        if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;&#10;      }&#10;    }&#10;    return true;&#10;  }&#10;  &#10;  PolyK.IsConvex = function(p)&#10;  {&#10;    if(p.length&lt;6) return true;&#10;    var l = p.length - 4;&#10;    for(var i=0; i&lt;l; i+=2)&#10;      if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;&#10;    if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;&#10;    if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;&#10;    return true;&#10;  }&#10;  &#10;  PolyK.GetArea = function(p)&#10;  {&#10;    if(p.length &lt;6) return 0;&#10;    var l = p.length - 2;&#10;    var sum = 0;&#10;    for(var i=0; i&lt;l; i+=2)&#10;      sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);&#10;    sum += (p[0]-p[l]) * (p[l+1]+p[1]);&#10;    return - sum * 0.5;&#10;  }&#10;  &#10;  PolyK.GetAABB = function(p)&#10;  {&#10;    var minx = Infinity; &#10;    var miny = Infinity;&#10;    var maxx = -minx;&#10;    var maxy = -miny;&#10;    for(var i=0; i&lt;p.length; i+=2)&#10;    {&#10;      minx = Math.min(minx, p[i  ]);&#10;      maxx = Math.max(maxx, p[i  ]);&#10;      miny = Math.min(miny, p[i+1]);&#10;      maxy = Math.max(maxy, p[i+1]);&#10;    }&#10;    return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};&#10;  }&#10;  &#10;  PolyK.Reverse = function(p)&#10;  {&#10;    var np = [];&#10;    for(var j=p.length-2; j&gt;=0; j-=2)  np.push(p[j], p[j+1])&#10;    return np;&#10;  }&#10;  &#10;&#10;  PolyK.Triangulate = function(p)&#10;  {&#10;    var n = p.length&gt;&gt;1;&#10;    if(n&lt;3) return [];&#10;    var tgs = [];&#10;    var avl = [];&#10;    for(var i=0; i&lt;n; i++) avl.push(i);&#10;    &#10;    var i = 0;&#10;    var al = n;&#10;    while(al &gt; 3)&#10;    {&#10;      var i0 = avl[(i+0)%al];&#10;      var i1 = avl[(i+1)%al];&#10;      var i2 = avl[(i+2)%al];&#10;      &#10;      var ax = p[2*i0],  ay = p[2*i0+1];&#10;      var bx = p[2*i1],  by = p[2*i1+1];&#10;      var cx = p[2*i2],  cy = p[2*i2+1];&#10;      &#10;      var earFound = false;&#10;      if(PolyK._convex(ax, ay, bx, by, cx, cy))&#10;      {&#10;        earFound = true;&#10;        for(var j=0; j&lt;al; j++)&#10;        {&#10;          var vi = avl[j];&#10;          if(vi==i0 || vi==i1 || vi==i2) continue;&#10;          if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}&#10;        }&#10;      }&#10;      if(earFound)&#10;      {&#10;        tgs.push(i0, i1, i2);&#10;        avl.splice((i+1)%al, 1);&#10;        al--;&#10;        i= 0;&#10;      }&#10;      else if(i++ &gt; 3*al) break;    // no convex angles :(&#10;    }&#10;    tgs.push(avl[0], avl[1], avl[2]);&#10;    return tgs;&#10;  }&#10;  &#10;  PolyK.ContainsPoint = function(p, px, py)&#10;  {&#10;    var n = p.length&gt;&gt;1;&#10;    var ax, ay = p[2*n-3]-py, bx = p[2*n-2]-px, by = p[2*n-1]-py;&#10;    &#10;    //var lup = by &gt; ay;&#10;    for(var i=0; i&lt;n; i++)&#10;    {&#10;      ax = bx;  ay = by;&#10;      bx = p[2*i  ] - px;&#10;      by = p[2*i+1] - py;&#10;      if(ay==by) continue;&#10;      lup = by&gt;ay;&#10;    }&#10;    &#10;    var depth = 0;&#10;    for(var i=0; i&lt;n; i++)&#10;    {&#10;      ax = bx;  ay = by;&#10;      bx = p[2*i  ] - px;&#10;      by = p[2*i+1] - py;&#10;      if(ay&lt; 0 &amp;&amp; by&lt; 0) continue;  // both &quot;up&quot; or both &quot;down&quot;&#10;      if(ay&gt; 0 &amp;&amp; by&gt; 0) continue;  // both &quot;up&quot; or both &quot;down&quot;&#10;      if(ax&lt; 0 &amp;&amp; bx&lt; 0) continue;  // both points on the left&#10;      &#10;      if(ay==by &amp;&amp; Math.min(ax,bx)&lt;=0) return true;&#10;      if(ay==by) continue;&#10;      &#10;      var lx = ax + (bx-ax)*(-ay)/(by-ay);&#10;      if(lx==0) return true;      // point on edge&#10;      if(lx&gt; 0) depth++;&#10;      if(ay==0 &amp;&amp;  lup &amp;&amp; by&gt;ay) depth--; // hit vertex, both up&#10;      if(ay==0 &amp;&amp; !lup &amp;&amp; by&lt;ay) depth--; // hit vertex, both down&#10;      lup = by&gt;ay;&#10;    }&#10;    //console.log(depth);&#10;    return (depth &amp; 1) == 1;&#10;  }&#10;  &#10;  PolyK.Slice = function(p, ax, ay, bx, by)&#10;  {&#10;    if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];&#10;&#10;    var a = new PolyK._P(ax, ay);&#10;    var b = new PolyK._P(bx, by);&#10;    var iscs = [];  // intersections&#10;    var ps = [];  // points&#10;    for(var i=0; i&lt;p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));&#10;    &#10;    for(var i=0; i&lt;ps.length; i++)&#10;    {&#10;      var isc = new PolyK._P(0,0);&#10;      isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);&#10;      var fisc = iscs[0];&#10;      var lisc = iscs[iscs.length-1];&#10;      if(isc &amp;&amp; (fisc==null || PolyK._P.dist(isc,fisc)&gt;1e-10) &amp;&amp; (lisc==null || PolyK._P.dist(isc,lisc)&gt;1e-10 ) )//&amp;&amp; (isc.x!=ps[i].x || isc.y!=ps[i].y) )&#10;      {&#10;        isc.flag = true;&#10;        iscs.push(isc);&#10;        ps.splice(i+1,0,isc);&#10;        i++;&#10;      }&#10;    }&#10;    &#10;    if(iscs.length &lt;2) return [p.slice(0)];&#10;    var comp = function(u,v) { return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }&#10;    iscs.sort(comp);&#10;    &#10;    //console.log(&quot;Intersections: &quot;+iscs.length, JSON.stringify(iscs));&#10;    &#10;    var pgs = [];&#10;    var dir = 0;&#10;    while(iscs.length &gt; 0)&#10;    {&#10;      var n = ps.length;&#10;      var i0 = iscs[0];&#10;      var i1 = iscs[1];&#10;      //if(i0.x==i1.x &amp;&amp; i0.y==i1.y) { iscs.splice(0,2); continue;}&#10;      var ind0 = ps.indexOf(i0);&#10;      var ind1 = ps.indexOf(i1);&#10;      var solved = false;&#10;      &#10;      //console.log(i0, i1);&#10;      &#10;      if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;&#10;      else&#10;      {&#10;        i0 = iscs[1];&#10;        i1 = iscs[0];&#10;        ind0 = ps.indexOf(i0);&#10;        ind1 = ps.indexOf(i1);&#10;        if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;&#10;      }&#10;      if(solved)&#10;      {&#10;        dir--;&#10;        var pgn = PolyK._getPoints(ps, ind0, ind1);&#10;        pgs.push(pgn);&#10;        ps = PolyK._getPoints(ps, ind1, ind0);&#10;        i0.flag = i1.flag = false;&#10;        iscs.splice(0,2);&#10;        if(iscs.length == 0) pgs.push(ps);&#10;      }&#10;      else { dir++; iscs.reverse(); }&#10;      if(dir&gt;1) break;&#10;    }&#10;    var result = [];&#10;    for(var i=0; i&lt;pgs.length; i++)&#10;    {&#10;      var pg = pgs[i];&#10;      var npg = [];&#10;      for(var j=0; j&lt;pg.length; j++) npg.push(pg[j].x, pg[j].y);&#10;      result.push(npg);&#10;    }&#10;    return result;&#10;  }&#10;  &#10;  PolyK.Raycast = function(p, x, y, dx, dy, isc)&#10;  {&#10;    var l = p.length - 2;&#10;    var tp = PolyK._tp;&#10;    var a1 = tp[0], a2 = tp[1], &#10;    b1 = tp[2], b2 = tp[3], c = tp[4];&#10;    a1.x = x; a1.y = y;&#10;    a2.x = x+dx; a2.y = y+dy;&#10;    &#10;    if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};&#10;    isc.dist = Infinity;&#10;    &#10;    for(var i=0; i&lt;l; i+=2)&#10;    {&#10;      b1.x = p[i  ];  b1.y = p[i+1];&#10;      b2.x = p[i+2];  b2.y = p[i+3];&#10;      var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);&#10;      if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);&#10;    }&#10;    b1.x = b2.x;  b1.y = b2.y;&#10;    b2.x = p[0];  b2.y = p[1];&#10;    var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);&#10;    if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, (p.length/2)-1, isc);&#10;    &#10;    return (isc.dist != Infinity) ? isc : null;&#10;  }&#10;  &#10;  PolyK.ClosestEdge = function(p, x, y, isc)&#10;  {&#10;    var l = p.length - 2;&#10;    var tp = PolyK._tp;&#10;    var a1 = tp[0], &#10;    b1 = tp[2], b2 = tp[3], c = tp[4];&#10;    a1.x = x; a1.y = y;&#10;    &#10;    if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};&#10;    isc.dist = Infinity;&#10;    &#10;    for(var i=0; i&lt;l; i+=2)&#10;    {&#10;      b1.x = p[i  ];  b1.y = p[i+1];&#10;      b2.x = p[i+2];  b2.y = p[i+3];&#10;      PolyK._pointLineDist(a1, b1, b2, i&gt;&gt;1, isc);&#10;    }&#10;    b1.x = b2.x;  b1.y = b2.y;&#10;    b2.x = p[0];  b2.y = p[1];&#10;    PolyK._pointLineDist(a1, b1, b2, l&gt;&gt;1, isc);&#10;    &#10;    var idst = 1/isc.dist;&#10;    isc.norm.x = (x-isc.point.x)*idst;&#10;    isc.norm.y = (y-isc.point.y)*idst;&#10;    return isc;&#10;  }&#10;  &#10;  PolyK._pointLineDist = function(p, a, b, edge, isc)&#10;  {&#10;    var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;&#10;    &#10;    var A = x - x1;&#10;    var B = y - y1;&#10;    var C = x2 - x1;&#10;    var D = y2 - y1;&#10;&#10;    var dot = A * C + B * D;&#10;    var len_sq = C * C + D * D;&#10;    var param = dot / len_sq;&#10;&#10;    var xx, yy;&#10;&#10;    if (param &lt; 0 || (x1 == x2 &amp;&amp; y1 == y2)) {&#10;      xx = x1;&#10;      yy = y1;&#10;    }&#10;    else if (param &gt; 1) {&#10;      xx = x2;&#10;      yy = y2;&#10;    }&#10;    else {&#10;      xx = x1 + param * C;&#10;      yy = y1 + param * D;&#10;    }&#10;&#10;    var dx = x - xx;&#10;    var dy = y - yy;&#10;    var dst = Math.sqrt(dx * dx + dy * dy);&#10;    if(dst&lt;isc.dist)&#10;    {&#10;      isc.dist = dst;&#10;      isc.edge = edge;&#10;      isc.point.x = xx;&#10;      isc.point.y = yy;&#10;    }&#10;  }&#10;  &#10;  PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)&#10;  {&#10;    var nrl = PolyK._P.dist(a1, c);&#10;    if(nrl&lt;isc.dist)&#10;    {&#10;      var ibl = 1/PolyK._P.dist(b1, b2);&#10;      var nx = -(b2.y-b1.y)*ibl;&#10;      var ny =  (b2.x-b1.x)*ibl;&#10;      var ddot = 2*(dx*nx+dy*ny);&#10;      isc.dist = nrl;&#10;      isc.norm.x = nx;  &#10;      isc.norm.y = ny; &#10;      isc.refl.x = -ddot*nx+dx;&#10;      isc.refl.y = -ddot*ny+dy;&#10;      isc.edge = edge;&#10;    }&#10;  }&#10;  &#10;  PolyK._getPoints = function(ps, ind0, ind1)&#10;  {&#10;    var n = ps.length;&#10;    var nps = [];&#10;    if(ind1&lt;ind0) ind1 += n;&#10;    for(var i=ind0; i&lt;= ind1; i++) nps.push(ps[i%n]);&#10;    return nps;&#10;  }&#10;  &#10;  PolyK._firstWithFlag = function(ps, ind)&#10;  {&#10;    var n = ps.length;&#10;    while(true)&#10;    {&#10;      ind = (ind+1)%n;&#10;      if(ps[ind].flag) return ind;&#10;    }&#10;  }&#10;  &#10;  PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)&#10;  {&#10;    var v0x = cx-ax;&#10;    var v0y = cy-ay;&#10;    var v1x = bx-ax;&#10;    var v1y = by-ay;&#10;    var v2x = px-ax;&#10;    var v2y = py-ay;&#10;    &#10;    var dot00 = v0x*v0x+v0y*v0y;&#10;    var dot01 = v0x*v1x+v0y*v1y;&#10;    var dot02 = v0x*v2x+v0y*v2y;&#10;    var dot11 = v1x*v1x+v1y*v1y;&#10;    var dot12 = v1x*v2x+v1y*v2y;&#10;    &#10;    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);&#10;    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;&#10;    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;&#10;&#10;    // Check if point is in triangle&#10;    return (u &gt;= 0) &amp;&amp; (v &gt;= 0) &amp;&amp; (u + v &lt; 1);&#10;  }&#10;  &#10;  PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)&#10;  {&#10;    var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);&#10;    var day = (a1.y-a2.y), dby = (b1.y-b2.y);&#10;&#10;    var Den = dax*dby - day*dbx;&#10;    if (Den == 0) return null;  // parallel&#10;    &#10;    var A = (a1.x * a2.y - a1.y * a2.x);&#10;    var B = (b1.x * b2.y - b1.y * b2.x);&#10;    &#10;    var I = c;&#10;    var iDen = 1/Den;&#10;    I.x = ( A*dbx - dax*B ) * iDen;&#10;    I.y = ( A*dby - day*B ) * iDen;&#10;    &#10;    if(!PolyK._InRect(I, b1, b2)) return null;&#10;    if((day&gt;0 &amp;&amp; I.y&gt;a1.y) || (day&lt;0 &amp;&amp; I.y&lt;a1.y)) return null; &#10;    if((dax&gt;0 &amp;&amp; I.x&gt;a1.x) || (dax&lt;0 &amp;&amp; I.x&lt;a1.x)) return null; &#10;    return I;&#10;  }&#10;  &#10;  PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)&#10;  {&#10;    var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);&#10;    var day = (a1.y-a2.y), dby = (b1.y-b2.y);&#10;&#10;    var Den = dax*dby - day*dbx;&#10;    if (Den == 0) return null;  // parallel&#10;    &#10;    var A = (a1.x * a2.y - a1.y * a2.x);&#10;    var B = (b1.x * b2.y - b1.y * b2.x);&#10;    &#10;    var I = c;&#10;    I.x = ( A*dbx - dax*B ) / Den;&#10;    I.y = ( A*dby - day*B ) / Den;&#10;    &#10;    if(PolyK._InRect(I, a1, a2) &amp;&amp; PolyK._InRect(I, b1, b2)) return I;&#10;    return null;&#10;  }&#10;  &#10;  PolyK._InRect = function(a, b, c) // a in rect (b,c)&#10;  {&#10;    var minx = Math.min(b.x,c.x), maxx = Math.max(b.x,c.x);&#10;    var miny = Math.min(b.y,c.y), maxy = Math.max(b.y,c.y);&#10;    &#10;    if  (minx == maxx) return (miny&lt;=a.y &amp;&amp; a.y&lt;=maxy);&#10;    if  (miny == maxy) return (minx&lt;=a.x &amp;&amp; a.x&lt;=maxx);&#10;    &#10;    //return (minx &lt;= a.x &amp;&amp; a.x &lt;= maxx &amp;&amp; miny &lt;= a.y &amp;&amp; a.y &lt;= maxy)&#10;    return (minx &lt;= a.x+1e-10 &amp;&amp; a.x-1e-10 &lt;= maxx &amp;&amp; miny &lt;= a.y+1e-10 &amp;&amp; a.y-1e-10 &lt;= maxy) ;   &#10;  }&#10;  &#10;  PolyK._convex = function(ax, ay, bx, by, cx, cy)&#10;  {&#10;    return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) &gt;= 0;&#10;  }&#10;    &#10;  PolyK._P = function(x,y)&#10;  {&#10;    this.x = x;&#10;    this.y = y;&#10;    this.flag = false;&#10;  }&#10;  PolyK._P.prototype.toString = function()&#10;  {&#10;    return &quot;Point [&quot;+this.x+&quot;, &quot;+this.y+&quot;]&quot;;&#10;  }&#10;  PolyK._P.dist = function(a,b)&#10;  {&#10;    var dx = b.x-a.x;&#10;    var dy = b.y-a.y;&#10;    return Math.sqrt(dx*dx + dy*dy);&#10;  }&#10;  &#10;  PolyK._tp = [];&#10;  for(var i=0; i&lt;10; i++) PolyK._tp.push(new PolyK._P(0,0));&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/Container.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="Boundary" class="ptolemy.data.expr.Parameter" value="0,0,2.03,0,2.03,2.3,3.88,2.3,3.88,7.77,2.97,7.77,2.97,9.7,1.02,9.7,1.02,6.7,-2.9,6.7,-2.9,4.19,0,4.19">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1010.0, 215.0]">
        </property>
        <port name="PoseIn" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="PoseOut" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Display" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={590, 421, 864, 272}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1155.0, 215.0]">
        </property>
    </entity>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="DiscreteClock.output" relation="relation"/>
    <link port="StringConst2.output" relation="relation2"/>
    <link port="StringConst2.trigger" relation="relation"/>
    <link port="CoordinateLinearTransform.Input" relation="relation3"/>
    <link port="CoordinateLinearTransform.Output" relation="relation7"/>
    <link port="FakeLocationStream2.ID" relation="relation2"/>
    <link port="FakeLocationStream2.Location" relation="relation3"/>
    <link port="Command2Pose.Command" relation="relation4"/>
    <link port="Command2Pose.Pose" relation="relation5"/>
    <link port="Location2Command.Location" relation="relation7"/>
    <link port="Location2Command.Command" relation="relation4"/>
    <link port="Container.PoseIn" relation="relation5"/>
    <link port="Container.PoseOut" relation="relation6"/>
    <link port="Display.input" relation="relation6"/>
</entity>
