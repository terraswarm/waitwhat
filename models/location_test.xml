<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="location_test" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{384.0, 311.0}">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={5, 23, 1671, 1023}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1437, 913]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{708.5, 446.5}">
    </property>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <doc>Create periodic timed events.</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[140.0, 605.0]">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="multiport"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="period" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="start" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="stop" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="FakeLocationStream" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Generate a stream of made up location data.&#10; *&#10; *  Outputs an object that looks like:&#10; *&#10; *      {&#10; *        id: &lt;unique id per thing being localized&gt;&#10; *        X:  &lt;x coordinate&gt;&#10; *        Y:  &lt;x coordinate&gt;&#10; *        Z:  &lt;x coordinate&gt;&#10; *      }&#10; *&#10; *  @accessor FakeLocationStream&#10; *&#10;*/&#10;&#10;// Which ID we should be generating location data for&#10;var current_id;&#10;&#10;// Last location&#10;var x;&#10;var y;&#10;var z;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('ID', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;1&quot;&#10;  });&#10;  output('Location', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // How often to generate a new location value in seconds&#10;  parameter('Period', {&#10;    value: 1,&#10;    type: 'number'&#10;  });&#10;&#10;  // Bounds of generated locations in meters&#10;  parameter('MinX', {value: 0, type: 'number'});&#10;  parameter('MaxX', {value: 10, type: 'number'});&#10;  parameter('MinY', {value: 0, type: 'number'});&#10;  parameter('MaxY', {value: 10, type: 'number'});&#10;  parameter('MinZ', {value: 1, type: 'number'});&#10;  parameter('MaxZ', {value: 2, type: 'number'});&#10;&#10;  // How much any one parameter can vary between updates&#10;  parameter('MaxVariance', {value: 0.2, type: 'number'});&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('ID', ID_in);&#10;&#10;  current_id = get('ID');&#10;  x = getParameter('MinX');&#10;  y = getParameter('MinY');&#10;  z = getParameter('MinZ');&#10;&#10;  // Use the period parameter to setup the loop that generates fake&#10;  // location data.&#10;  setInterval(update_location, getParameter('Period')*1000);&#10;}&#10;&#10;function getRandomArbitrary (min, max) {&#10;  return Math.random() * (max - min) + min;&#10;}&#10;&#10;function getRandomInt (min, max) {&#10;  return Math.floor(Math.random() * (max - min)) + min;&#10;}&#10;&#10;// Generates a new location value and sends to output based on parameters set&#10;function update_location () {&#10;&#10;  var j = getParameter('MaxVariance');&#10;  var alter = getRandomArbitrary(j/2, j);&#10;  var neg = getRandomInt(1, 3);&#10;  if (neg == 1) {&#10;    alter *= -1;&#10;  }&#10;&#10;  // Choose which axis to change on this iteration&#10;  var whichone = getRandomInt(0, 3);&#10;&#10;  if (whichone == 0) {&#10;    // ALTER X&#10;    var new_x = x + alter;&#10;    if (new_x &lt; getParameter('MinX')) new_x = getParameter('MinX');&#10;    if (new_x &gt; getParameter('MaxX')) new_x = getParameter('MaxX');&#10;    x = new_x;&#10;  &#10;  } else if (whichone == 1) {&#10;    // ALTER Y&#10;    var new_y = y + alter;&#10;    if (new_y &lt; getParameter('MinY')) new_y = getParameter('MinY');&#10;    if (new_y &gt; getParameter('MaxY')) new_y = getParameter('MaxY');&#10;    y = new_y;&#10;&#10;  } else if (whichone == 2) {&#10;    // ALTER Z&#10;    var new_z = z + alter;&#10;    if (new_z &lt; getParameter('MinZ')) new_z = getParameter('MinZ');&#10;    if (new_z &gt; getParameter('MaxZ')) new_z = getParameter('MaxZ');&#10;    z = new_z;&#10;&#10;  }&#10;&#10;  var loc = {&#10;    id: current_id,&#10;    X: x,&#10;    Y: y,&#10;    Z: z&#10;  };&#10;&#10;  send('Location', loc);&#10;&#10;}&#10;&#10;&#10;var ID_in  = function () {&#10;  current_id = get('ID');&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/FakeLocationStream.js">
        </property>
        <property name="ID" class="ptolemy.actor.parameters.PortParameter" value="&quot;loc0&quot;">
        </property>
        <property name="Period" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MinX" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxX" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinY" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxY" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinZ" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MaxZ" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="MaxVariance" class="ptolemy.data.expr.Parameter" value="0.5">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[390.0, 465.0]">
        </property>
        <port name="ID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="StringConst" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="loc0">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[305.0, 465.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
    </entity>
    <entity name="OpFilter" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/OpFilter.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[960.0, 470.0]">
        </property>
        <property name="key" class="ptolemy.data.expr.StringParameter" value="id">
        </property>
        <property name="value" class="ptolemy.data.expr.StringParameter" value="loc0">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="FakeLocationStream2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Generate a stream of made up location data.&#10; *&#10; *  Outputs an object that looks like:&#10; *&#10; *      {&#10; *        id: &lt;unique id per thing being localized&gt;&#10; *        X:  &lt;x coordinate&gt;&#10; *        Y:  &lt;x coordinate&gt;&#10; *        Z:  &lt;x coordinate&gt;&#10; *      }&#10; *&#10; *  @accessor FakeLocationStream&#10; *&#10;*/&#10;&#10;// Which ID we should be generating location data for&#10;var current_id;&#10;&#10;// Last location&#10;var x;&#10;var y;&#10;var z;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('ID', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;1&quot;&#10;  });&#10;  output('Location', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // How often to generate a new location value in seconds&#10;  parameter('Period', {&#10;    value: 1,&#10;    type: 'number'&#10;  });&#10;&#10;  // Bounds of generated locations in meters&#10;  parameter('MinX', {value: 0, type: 'number'});&#10;  parameter('MaxX', {value: 10, type: 'number'});&#10;  parameter('MinY', {value: 0, type: 'number'});&#10;  parameter('MaxY', {value: 10, type: 'number'});&#10;  parameter('MinZ', {value: 1, type: 'number'});&#10;  parameter('MaxZ', {value: 2, type: 'number'});&#10;&#10;  // How much any one parameter can vary between updates&#10;  parameter('MaxVariance', {value: 0.2, type: 'number'});&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('ID', ID_in);&#10;&#10;  current_id = get('ID');&#10;  x = getParameter('MinX');&#10;  y = getParameter('MinY');&#10;  z = getParameter('MinZ');&#10;&#10;  // Use the period parameter to setup the loop that generates fake&#10;  // location data.&#10;  setInterval(update_location, getParameter('Period')*1000);&#10;}&#10;&#10;function getRandomArbitrary (min, max) {&#10;  return Math.random() * (max - min) + min;&#10;}&#10;&#10;function getRandomInt (min, max) {&#10;  return Math.floor(Math.random() * (max - min)) + min;&#10;}&#10;&#10;// Generates a new location value and sends to output based on parameters set&#10;function update_location () {&#10;&#10;  var j = getParameter('MaxVariance');&#10;  var alter = getRandomArbitrary(j/2, j);&#10;  var neg = getRandomInt(1, 3);&#10;  if (neg == 1) {&#10;    alter *= -1;&#10;  }&#10;&#10;  // Choose which axis to change on this iteration&#10;  var whichone = getRandomInt(0, 3);&#10;&#10;  if (whichone == 0) {&#10;    // ALTER X&#10;    var new_x = x + alter;&#10;    if (new_x &lt; getParameter('MinX')) new_x = getParameter('MinX');&#10;    if (new_x &gt; getParameter('MaxX')) new_x = getParameter('MaxX');&#10;    x = new_x;&#10;  &#10;  } else if (whichone == 1) {&#10;    // ALTER Y&#10;    var new_y = y + alter;&#10;    if (new_y &lt; getParameter('MinY')) new_y = getParameter('MinY');&#10;    if (new_y &gt; getParameter('MaxY')) new_y = getParameter('MaxY');&#10;    y = new_y;&#10;&#10;  } else if (whichone == 2) {&#10;    // ALTER Z&#10;    var new_z = z + alter;&#10;    if (new_z &lt; getParameter('MinZ')) new_z = getParameter('MinZ');&#10;    if (new_z &gt; getParameter('MaxZ')) new_z = getParameter('MaxZ');&#10;    z = new_z;&#10;&#10;  }&#10;&#10;  var loc = {&#10;    id: current_id,&#10;    X: x,&#10;    Y: y,&#10;    Z: z&#10;  };&#10;&#10;  send('Location', loc);&#10;&#10;}&#10;&#10;&#10;var ID_in  = function () {&#10;  current_id = get('ID');&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/FakeLocationStream.js">
        </property>
        <property name="ID" class="ptolemy.actor.parameters.PortParameter" value="&quot;loc1&quot;">
        </property>
        <property name="Period" class="ptolemy.data.expr.Parameter" value="5.0">
        </property>
        <property name="MinX" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxX" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinY" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxY" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinZ" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MaxZ" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="MaxVariance" class="ptolemy.data.expr.Parameter" value="0.5">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[385.0, 560.0]">
        </property>
        <port name="ID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="StringConst2" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="loc1">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[305.0, 560.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
    </entity>
    <entity name="CoordinateLinearTransform" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Shifts X,Y,Z coordinates&#10; *&#10; *  @accessor CoordinateLinearTransform&#10; *&#10;*/&#10;&#10;var shifts = {&#10;  X: 0,&#10;  Y: 0,&#10;  Z: 0&#10;};&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  parameter('Xshift', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;  parameter('Yshift', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;  parameter('Zshift', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  shifts.X = getParameter('Xshift');&#10;  shifts.Y = getParameter('Yshift');&#10;  shifts.Z = getParameter('Zshift');&#10;}&#10;&#10;var Input_in = function () {&#10;  var v = get('Input');&#10;&#10;  var axes = ['X', 'Y', 'Z'];&#10;  for (i=0; i&lt;axes.length; i++) {&#10;    var axis = axes[i];&#10;&#10;    if (typeof v === 'object' &amp;&amp; axis in v &amp;&amp; v.hasOwnProperty(axis)) {&#10;      v[axis] += shifts[axis];&#10;    }&#10;  }&#10;&#10;  send('Output', v);&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/CoordinateLinearTransform.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[625.0, 605.0]">
        </property>
        <property name="Xshift" class="ptolemy.data.expr.Parameter" value="-0.465">
        </property>
        <property name="Yshift" class="ptolemy.data.expr.Parameter" value="4.146">
        </property>
        <property name="Zshift" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="MoveActionGoalMessage" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Create a MoveActionGoal ROS message from an X,Y,Z coordinate.&#10; *&#10; *  @accessor MoveActionGoalMessage&#10; *&#10;*/&#10;&#10;var seq = 0;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;}&#10;&#10;var Input_in = function () {&#10;  var v = get('Input');&#10;&#10;  var x = v.X || 0; &#10;  var y = v.Y || 0; &#10;  var z = v.Z || 0; &#10;&#10;  out = {&#10;    'header': {&#10;      'seq': seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      },&#10;      'frame_id': 'map_hokuyo'&#10;    },&#10;    'goal_id': {&#10;      'id': 'hi' + seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      }&#10;    },&#10;    'goal': {&#10;      'stop': false,&#10;      'target_poses': [{&#10;        'pose': {&#10;          'position': {&#10;            'x': x,&#10;            'y': y,&#10;            'z': 0.0},&#10;          'orientation': {&#10;            'x': 0.0,&#10;            'y': 0.0,&#10;            'z': 0.0,&#10;            'w': 1.0}&#10;           }&#10;          }&#10;       ]&#10;    }&#10;  }&#10;&#10;  seq++;&#10;&#10;  send('Output', out);&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/MoveActionGoalMessage.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1100.0, 470.0]">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10;   exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RosPublisher.js">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="141.212.11.124">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/scarab/lane/move/goal">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="scarab_msgs/MoveActionGoal">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1275.0, 470.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="Display4" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={229, 80, 1193, 447}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[759, 262]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1265.0, 290.0]">
        </property>
    </entity>
    <entity name="FakeLocationStream3" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Generate a stream of made up location data.&#10; *&#10; *  Outputs an object that looks like:&#10; *&#10; *      {&#10; *        id: &lt;unique id per thing being localized&gt;&#10; *        X:  &lt;x coordinate&gt;&#10; *        Y:  &lt;x coordinate&gt;&#10; *        Z:  &lt;x coordinate&gt;&#10; *      }&#10; *&#10; *  @accessor FakeLocationStream&#10; *&#10;*/&#10;&#10;// Which ID we should be generating location data for&#10;var current_id;&#10;&#10;// Last location&#10;var x;&#10;var y;&#10;var z;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('ID', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;1&quot;&#10;  });&#10;  output('Location', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // How often to generate a new location value in seconds&#10;  parameter('Period', {&#10;    value: 1,&#10;    type: 'number'&#10;  });&#10;&#10;  // Bounds of generated locations in meters&#10;  parameter('MinX', {value: 0, type: 'number'});&#10;  parameter('MaxX', {value: 10, type: 'number'});&#10;  parameter('MinY', {value: 0, type: 'number'});&#10;  parameter('MaxY', {value: 10, type: 'number'});&#10;  parameter('MinZ', {value: 1, type: 'number'});&#10;  parameter('MaxZ', {value: 2, type: 'number'});&#10;&#10;  // How much any one parameter can vary between updates&#10;  parameter('MaxVariance', {value: 0.2, type: 'number'});&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('ID', ID_in);&#10;&#10;  current_id = get('ID');&#10;  x = getParameter('MinX');&#10;  y = getParameter('MinY');&#10;  z = getParameter('MinZ');&#10;&#10;  // Use the period parameter to setup the loop that generates fake&#10;  // location data.&#10;  setInterval(update_location, getParameter('Period')*1000);&#10;}&#10;&#10;function getRandomArbitrary (min, max) {&#10;  return Math.random() * (max - min) + min;&#10;}&#10;&#10;function getRandomInt (min, max) {&#10;  return Math.floor(Math.random() * (max - min)) + min;&#10;}&#10;&#10;// Generates a new location value and sends to output based on parameters set&#10;function update_location () {&#10;&#10;  var j = getParameter('MaxVariance');&#10;  var alter = getRandomArbitrary(j/2, j);&#10;  var neg = getRandomInt(1, 3);&#10;  if (neg == 1) {&#10;    alter *= -1;&#10;  }&#10;&#10;  // Choose which axis to change on this iteration&#10;  var whichone = getRandomInt(0, 3);&#10;&#10;  if (whichone == 0) {&#10;    // ALTER X&#10;    var new_x = x + alter;&#10;    if (new_x &lt; getParameter('MinX')) new_x = getParameter('MinX');&#10;    if (new_x &gt; getParameter('MaxX')) new_x = getParameter('MaxX');&#10;    x = new_x;&#10;  &#10;  } else if (whichone == 1) {&#10;    // ALTER Y&#10;    var new_y = y + alter;&#10;    if (new_y &lt; getParameter('MinY')) new_y = getParameter('MinY');&#10;    if (new_y &gt; getParameter('MaxY')) new_y = getParameter('MaxY');&#10;    y = new_y;&#10;&#10;  } else if (whichone == 2) {&#10;    // ALTER Z&#10;    var new_z = z + alter;&#10;    if (new_z &lt; getParameter('MinZ')) new_z = getParameter('MinZ');&#10;    if (new_z &gt; getParameter('MaxZ')) new_z = getParameter('MaxZ');&#10;    z = new_z;&#10;&#10;  }&#10;&#10;  var loc = {&#10;    id: current_id,&#10;    X: x,&#10;    Y: y,&#10;    Z: z&#10;  };&#10;&#10;  send('Location', loc);&#10;&#10;}&#10;&#10;&#10;var ID_in  = function () {&#10;  current_id = get('ID');&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/FakeLocationStream.js">
        </property>
        <property name="ID" class="ptolemy.actor.parameters.PortParameter" value="&quot;loc2&quot;">
        </property>
        <property name="Period" class="ptolemy.data.expr.Parameter" value="5.0">
        </property>
        <property name="MinX" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxX" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinY" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxY" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinZ" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MaxZ" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="MaxVariance" class="ptolemy.data.expr.Parameter" value="0.5">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[385.0, 655.0]">
        </property>
        <port name="ID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="StringConst3" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="loc2">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[305.0, 655.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
    </entity>
    <entity name="FakeLocationStream4" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Generate a stream of made up location data.&#10; *&#10; *  Outputs an object that looks like:&#10; *&#10; *      {&#10; *        id: &lt;unique id per thing being localized&gt;&#10; *        X:  &lt;x coordinate&gt;&#10; *        Y:  &lt;x coordinate&gt;&#10; *        Z:  &lt;x coordinate&gt;&#10; *      }&#10; *&#10; *  @accessor FakeLocationStream&#10; *&#10;*/&#10;&#10;// Which ID we should be generating location data for&#10;var current_id;&#10;&#10;// Last location&#10;var x;&#10;var y;&#10;var z;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('ID', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;1&quot;&#10;  });&#10;  output('Location', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // How often to generate a new location value in seconds&#10;  parameter('Period', {&#10;    value: 1,&#10;    type: 'number'&#10;  });&#10;&#10;  // Bounds of generated locations in meters&#10;  parameter('MinX', {value: 0, type: 'number'});&#10;  parameter('MaxX', {value: 10, type: 'number'});&#10;  parameter('MinY', {value: 0, type: 'number'});&#10;  parameter('MaxY', {value: 10, type: 'number'});&#10;  parameter('MinZ', {value: 1, type: 'number'});&#10;  parameter('MaxZ', {value: 2, type: 'number'});&#10;&#10;  // How much any one parameter can vary between updates&#10;  parameter('MaxVariance', {value: 0.2, type: 'number'});&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('ID', ID_in);&#10;&#10;  current_id = get('ID');&#10;  x = getParameter('MinX');&#10;  y = getParameter('MinY');&#10;  z = getParameter('MinZ');&#10;&#10;  // Use the period parameter to setup the loop that generates fake&#10;  // location data.&#10;  setInterval(update_location, getParameter('Period')*1000);&#10;}&#10;&#10;function getRandomArbitrary (min, max) {&#10;  return Math.random() * (max - min) + min;&#10;}&#10;&#10;function getRandomInt (min, max) {&#10;  return Math.floor(Math.random() * (max - min)) + min;&#10;}&#10;&#10;// Generates a new location value and sends to output based on parameters set&#10;function update_location () {&#10;&#10;  var j = getParameter('MaxVariance');&#10;  var alter = getRandomArbitrary(j/2, j);&#10;  var neg = getRandomInt(1, 3);&#10;  if (neg == 1) {&#10;    alter *= -1;&#10;  }&#10;&#10;  // Choose which axis to change on this iteration&#10;  var whichone = getRandomInt(0, 3);&#10;&#10;  if (whichone == 0) {&#10;    // ALTER X&#10;    var new_x = x + alter;&#10;    if (new_x &lt; getParameter('MinX')) new_x = getParameter('MinX');&#10;    if (new_x &gt; getParameter('MaxX')) new_x = getParameter('MaxX');&#10;    x = new_x;&#10;  &#10;  } else if (whichone == 1) {&#10;    // ALTER Y&#10;    var new_y = y + alter;&#10;    if (new_y &lt; getParameter('MinY')) new_y = getParameter('MinY');&#10;    if (new_y &gt; getParameter('MaxY')) new_y = getParameter('MaxY');&#10;    y = new_y;&#10;&#10;  } else if (whichone == 2) {&#10;    // ALTER Z&#10;    var new_z = z + alter;&#10;    if (new_z &lt; getParameter('MinZ')) new_z = getParameter('MinZ');&#10;    if (new_z &gt; getParameter('MaxZ')) new_z = getParameter('MaxZ');&#10;    z = new_z;&#10;&#10;  }&#10;&#10;  var loc = {&#10;    id: current_id,&#10;    X: x,&#10;    Y: y,&#10;    Z: z&#10;  };&#10;&#10;  send('Location', loc);&#10;&#10;}&#10;&#10;&#10;var ID_in  = function () {&#10;  current_id = get('ID');&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/FakeLocationStream.js">
        </property>
        <property name="ID" class="ptolemy.actor.parameters.PortParameter" value="&quot;loc3&quot;">
        </property>
        <property name="Period" class="ptolemy.data.expr.Parameter" value="5.0">
        </property>
        <property name="MinX" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxX" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinY" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="MaxY" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="MinZ" class="ptolemy.data.expr.Parameter" value="1.0">
        </property>
        <property name="MaxZ" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="MaxVariance" class="ptolemy.data.expr.Parameter" value="0.5">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[385.0, 750.0]">
        </property>
        <port name="ID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="StringConst4" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="loc3">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[305.0, 750.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
    </entity>
    <entity name="OpFilter2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/OpFilter.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[960.0, 560.0]">
        </property>
        <property name="key" class="ptolemy.data.expr.StringParameter" value="id">
        </property>
        <property name="value" class="ptolemy.data.expr.StringParameter" value="loc1">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="OpFilter3" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/OpFilter.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[960.0, 650.0]">
        </property>
        <property name="key" class="ptolemy.data.expr.StringParameter" value="id">
        </property>
        <property name="value" class="ptolemy.data.expr.StringParameter" value="loc2">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="OpFilter4" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Outputs objects that match a key,value filter.&#10; *&#10; *  @accessor OpFilter&#10; *&#10;*/&#10;&#10;// Filter params&#10;var key;&#10;var value;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // key,value pair that has to be present to have a packet meet the filter&#10;  parameter('key', {&#10;    type: 'string'&#10;  });&#10;  parameter('value', {&#10;    type: 'string'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  addInputHandler('Input', Input_in);&#10;&#10;  key = getParameter('key');&#10;  value = getParameter('value');&#10;}&#10;&#10;var Input_in = function () {&#10;  var i = get('Input');&#10;&#10;  if (typeof i === 'object' &amp;&amp; key in i &amp;&amp; i.hasOwnProperty(key) &amp;&amp; i[key] == value) {&#10;    send('Output', i);&#10;  }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/OpFilter.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[960.0, 735.0]">
        </property>
        <property name="key" class="ptolemy.data.expr.StringParameter" value="id">
        </property>
        <property name="value" class="ptolemy.data.expr.StringParameter" value="loc3">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="MoveActionGoalMessage2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Create a MoveActionGoal ROS message from an X,Y,Z coordinate.&#10; *&#10; *  @accessor MoveActionGoalMessage&#10; *&#10;*/&#10;&#10;var seq = 0;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;}&#10;&#10;var Input_in = function () {&#10;  var v = get('Input');&#10;&#10;  var x = v.X || 0; &#10;  var y = v.Y || 0; &#10;  var z = v.Z || 0; &#10;&#10;  out = {&#10;    'header': {&#10;      'seq': seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      },&#10;      'frame_id': 'map_hokuyo'&#10;    },&#10;    'goal_id': {&#10;      'id': 'hi' + seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      }&#10;    },&#10;    'goal': {&#10;      'stop': false,&#10;      'target_poses': [{&#10;        'pose': {&#10;          'position': {&#10;            'x': x,&#10;            'y': y,&#10;            'z': 0.0},&#10;          'orientation': {&#10;            'x': 0.0,&#10;            'y': 0.0,&#10;            'z': 0.0,&#10;            'w': 1.0}&#10;           }&#10;          }&#10;       ]&#10;    }&#10;  }&#10;&#10;  seq++;&#10;&#10;  send('Output', out);&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/MoveActionGoalMessage.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1100.0, 560.0]">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10;   exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RosPublisher.js">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="141.212.11.124">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/scarab/lizzy/move/goal">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="scarab_msgs/MoveActionGoal">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1275.0, 560.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="MoveActionGoalMessage3" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Create a MoveActionGoal ROS message from an X,Y,Z coordinate.&#10; *&#10; *  @accessor MoveActionGoalMessage&#10; *&#10;*/&#10;&#10;var seq = 0;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;}&#10;&#10;var Input_in = function () {&#10;  var v = get('Input');&#10;&#10;  var x = v.X || 0; &#10;  var y = v.Y || 0; &#10;  var z = v.Z || 0; &#10;&#10;  out = {&#10;    'header': {&#10;      'seq': seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      },&#10;      'frame_id': 'map_hokuyo'&#10;    },&#10;    'goal_id': {&#10;      'id': 'hi' + seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      }&#10;    },&#10;    'goal': {&#10;      'stop': false,&#10;      'target_poses': [{&#10;        'pose': {&#10;          'position': {&#10;            'x': x,&#10;            'y': y,&#10;            'z': 0.0},&#10;          'orientation': {&#10;            'x': 0.0,&#10;            'y': 0.0,&#10;            'z': 0.0,&#10;            'w': 1.0}&#10;           }&#10;          }&#10;       ]&#10;    }&#10;  }&#10;&#10;  seq++;&#10;&#10;  send('Output', out);&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/MoveActionGoalMessage.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1100.0, 650.0]">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher3" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10;   exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RosPublisher.js">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="141.212.11.124">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/scarab/loretta/move/goal">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="scarab_msgs/MoveActionGoal">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1275.0, 650.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="MoveActionGoalMessage4" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** Create a MoveActionGoal ROS message from an X,Y,Z coordinate.&#10; *&#10; *  @accessor MoveActionGoalMessage&#10; *&#10;*/&#10;&#10;var seq = 0;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  //&#10;  // I/O&#10;  //&#10;  input('Input', {&#10;    type: 'JSON'&#10;  });&#10;  output('Output', {&#10;    type: 'JSON'&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;  addInputHandler('Input', Input_in);&#10;}&#10;&#10;var Input_in = function () {&#10;  var v = get('Input');&#10;&#10;  var x = v.X || 0; &#10;  var y = v.Y || 0; &#10;  var z = v.Z || 0; &#10;&#10;  out = {&#10;    'header': {&#10;      'seq': seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      },&#10;      'frame_id': 'map_hokuyo'&#10;    },&#10;    'goal_id': {&#10;      'id': 'hi' + seq,&#10;      'stamp': {&#10;        'secs': 0,&#10;        'nsecs': 0&#10;      }&#10;    },&#10;    'goal': {&#10;      'stop': false,&#10;      'target_poses': [{&#10;        'pose': {&#10;          'position': {&#10;            'x': x,&#10;            'y': y,&#10;            'z': 0.0},&#10;          'orientation': {&#10;            'x': 0.0,&#10;            'y': 0.0,&#10;            'z': 0.0,&#10;            'w': 1.0}&#10;           }&#10;          }&#10;       ]&#10;    }&#10;  }&#10;&#10;  seq++;&#10;&#10;  send('Output', out);&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/git/waitwhat/accessors/MoveActionGoalMessage.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1100.0, 735.0]">
        </property>
        <port name="Input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher4" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10;   exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RosPublisher.js">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="141.212.11.124">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/scarab/lady/move/goal">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="scarab_msgs/MoveActionGoal">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1275.0, 735.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[545.0, 605.0]">
        </vertex>
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[220.0, 605.0]">
        </vertex>
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[790.0, 605.0]">
        </vertex>
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[1190.0, 470.0]">
        </vertex>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation12" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation13" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation14" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation15" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="DiscreteClock.output" relation="relation6"/>
    <link port="FakeLocationStream.ID" relation="relation"/>
    <link port="FakeLocationStream.Location" relation="relation4"/>
    <link port="StringConst.output" relation="relation"/>
    <link port="StringConst.trigger" relation="relation6"/>
    <link port="OpFilter.Input" relation="relation7"/>
    <link port="OpFilter.Output" relation="relation2"/>
    <link port="FakeLocationStream2.ID" relation="relation5"/>
    <link port="FakeLocationStream2.Location" relation="relation4"/>
    <link port="StringConst2.output" relation="relation5"/>
    <link port="StringConst2.trigger" relation="relation6"/>
    <link port="CoordinateLinearTransform.Input" relation="relation4"/>
    <link port="CoordinateLinearTransform.Output" relation="relation7"/>
    <link port="MoveActionGoalMessage.Input" relation="relation2"/>
    <link port="MoveActionGoalMessage.Output" relation="relation8"/>
    <link port="RosPublisher.toSend" relation="relation8"/>
    <link port="Display4.input" relation="relation8"/>
    <link port="FakeLocationStream3.ID" relation="relation9"/>
    <link port="FakeLocationStream3.Location" relation="relation4"/>
    <link port="StringConst3.output" relation="relation9"/>
    <link port="StringConst3.trigger" relation="relation6"/>
    <link port="FakeLocationStream4.ID" relation="relation10"/>
    <link port="FakeLocationStream4.Location" relation="relation4"/>
    <link port="StringConst4.output" relation="relation10"/>
    <link port="StringConst4.trigger" relation="relation6"/>
    <link port="OpFilter2.Input" relation="relation7"/>
    <link port="OpFilter2.Output" relation="relation11"/>
    <link port="OpFilter3.Input" relation="relation7"/>
    <link port="OpFilter3.Output" relation="relation12"/>
    <link port="OpFilter4.Input" relation="relation7"/>
    <link port="OpFilter4.Output" relation="relation15"/>
    <link port="MoveActionGoalMessage2.Input" relation="relation11"/>
    <link port="MoveActionGoalMessage2.Output" relation="relation3"/>
    <link port="RosPublisher2.toSend" relation="relation3"/>
    <link port="MoveActionGoalMessage3.Input" relation="relation12"/>
    <link port="MoveActionGoalMessage3.Output" relation="relation13"/>
    <link port="RosPublisher3.toSend" relation="relation13"/>
    <link port="MoveActionGoalMessage4.Input" relation="relation15"/>
    <link port="MoveActionGoalMessage4.Output" relation="relation14"/>
    <link port="RosPublisher4.toSend" relation="relation14"/>
</entity>
