<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="robot_cafe" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[265.0, 255.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={0, 23, 1680, 1023}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1446, 913]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.2500000000000053">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{585.0418604651162, 420.0986918604651}">
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="false">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Raw location data&#10;from phones">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[210.0, 355.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Snack requests from users">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[210.0, 495.0]">
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Computed&#10;phone&#10;locations">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[505.0, 355.0]">
        </property>
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Orchestration">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[485.0, 505.0]">
        </property>
    </property>
    <property name="Annotation5" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Robot&#10;control">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[855.0, 355.0]">
        </property>
    </property>
    <property name="Annotation6" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Add&#10;robot&#10;ID">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[745.0, 395.0]">
        </property>
    </property>
    <property name="Annotation7" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Robot&#10;status">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[855.0, 460.0]">
        </property>
    </property>
    <entity name="WebSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  &lt;p&gt;The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; *  connection is opened or closed.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; *  output is produced with that message.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; *  sent to one or all of the open socket connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; *  server and all connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;The messages can be any type that has a JSON representation.&#10; *  For incomming messages, this accessor assumes that the message is&#10; *  a string in UTF-8 that encodes a JSON object.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10; *&#10; *  @accessor WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {number} port The port to listen to for connections.&#10; *  @input {JSON} toSend The data to be sent to open sockets. If this is a JSON object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output {JSON} connection An output produced when a connection opens or closes. The output is a JSON object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output {JSON} received A message received a client in the form of a JSON object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 205 2015-07-01 16:17:08Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend', {&#10;        type: &quot;JSON&quot;&#10;    });&#10;    output('received', {&#10;        type: &quot;JSON&quot;&#10;    });&#10;    output('connection', {&#10;        type: &quot;JSON&quot;&#10;    });&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({'port':getParameter('port'),&#10;                                       'hostInterface':getParameter('hostInterface')});&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/WebSocketServer.js">
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.StringParameter" value="141.212.11.234">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8081">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[230.0, 335.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_type" class="ptolemy.actor.TypeAttribute" value="{message=string,socketID=int}">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <doc>Create periodic timed events.</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[370.0, 255.0]">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="multiport"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="period" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="start" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="stop" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="JavaScript" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;exports.setup = function() {&#10;  input('input');&#10;  output('output');&#10;}&#10;exports.fire = function() {&#10;  var token = get('input');&#10;  //if (token &amp;&amp; token.message) {&#10;    send('message', token.message);&#10;  //}&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="16">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="80">
                </property>
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[360.0, 335.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="script" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="message" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_type" class="ptolemy.actor.TypeAttribute" value="string">
            </property>
        </port>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="WebSocketServer2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  &lt;p&gt;The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; *  connection is opened or closed.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; *  output is produced with that message.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; *  sent to one or all of the open socket connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; *  server and all connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;The messages can be any type that has a JSON representation.&#10; *  For incomming messages, this accessor assumes that the message is&#10; *  a string in UTF-8 that encodes a JSON object.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10; *&#10; *  @accessor WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {number} port The port to listen to for connections.&#10; *  @input {JSON} toSend The data to be sent to open sockets. If this is a JSON object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output {JSON} connection An output produced when a connection opens or closes. The output is a JSON object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output {JSON} received A message received a client in the form of a JSON object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 205 2015-07-01 16:17:08Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend', {&#10;        type: &quot;JSON&quot;&#10;    });&#10;    output('received', {&#10;        type: &quot;JSON&quot;&#10;    });&#10;    output('connection', {&#10;        type: &quot;JSON&quot;&#10;    });&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({'port':getParameter('port'),&#10;                                       'hostInterface':getParameter('hostInterface')});&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/WebSocketServer.js">
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.StringParameter" value="141.212.11.234">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8081">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[230.0, 475.0]">
        </property>
        <property name="_expertMode" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_type" class="ptolemy.actor.TypeAttribute" value="{message=string,socketID=int}">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Location" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor reads sensor and location data from a location host&#10; *  &lt;p&gt;&#10; *	The accessor makes REST GET requests to a location host to obtain sensor and location&#10; *	data. The type of data requested is defined by the dataType parameter. Possible values for&#10; *  the dataType parameter are:&#10; *	&quot;ibeacon&quot;: Fetches region UUID, major, minor, range, proximity and RSSI values of&#10; *	nearby iBeacons.&#10; *	&quot;alps&quot;: Fetches ALPS region ID, transmitter IDs, TOA and RSSI values of nearby ALPS&#10; *	transmitters&#10; *	&quot;imu&quot;: Fetches pedometer and heading values&#10; *	&quot;wifi&quot;: Fetches SSIDs, BSSIDs and RSSI values from nearby WiFi hotspots&#10; *	&quot;all&quot;: Fetches all of the above data at once&#10; *	All outputs are JSON formatted and contain UNIX timestamps of when the data was&#10; *	acquired by the location host.&#10; *  @accessor Location&#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var handlers = [];&#10;&#10;&#10;var http = require('httpClient');&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('SensorReading', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  }); &#10;  output('Location',{'type':'JSON'});&#10;}&#10;/* Initialize connection.*/&#10;exports.initialize = function() {&#10;   var ipAddress = get('HostIP');&#10;   var port = get('HostPort');&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the localization host.&quot;;&#10;   }&#10;    if (port == null || port.trim() == &quot;&quot;) {&#10;      throw &quot;No Port is given for the localization host.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;:&quot; + port;  &#10;   handle = addInputHandler('dataType', getData);&#10;}&#10;&#10;/* Get data over REST based on dataType input */&#10;function getData(){&#10;	var type = get('dataType');&#10;	switch(type){&#10;		case &quot;ibeacon&quot;:&#10;&#10;&#10;      http.get(url+'/ibeacon', function (request) {&#10;        send('iBeacon', request.body);&#10;      });&#10;&#10;&#10;			// send('iBeacon', httpRequest(url + &quot;/ibeacon&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;alps&quot;:&#10;			send('ALPS', httpRequest(url  + &quot;/alps&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;imu&quot;:&#10;			send('IMU', httpRequest(url  + &quot;/imu&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;wifi&quot;:&#10;			send('WiFi', httpRequest(url  + &quot;/wifi&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;location&quot;:&#10;			send('Location', httpRequest(url  + &quot;/location&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;all&quot;:&#10;			getAll();&#10;			break;&#10;		default:&#10;			getAll();&#10;	}&#10;}&#10;&#10;/* Get all location/sensor data */&#10;function getAll() {&#10;   	send('iBeacon', httpRequest(url + &quot;/ibeacon&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('ALPS', httpRequest(url  + &quot;/alps&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('IMU', httpRequest(url  + &quot;/imu&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('WiFi', httpRequest(url  + &quot;/wifi&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('Location', httpRequest(url  + &quot;/location&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;}&#10;	&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/Location.js">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[525.0, 335.0]">
        </property>
        <property name="SensorReading" class="ptolemy.actor.parameters.PortParameter" value="&quot;&quot;">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="SensorReading" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="Switch" class="ptolemy.actor.lib.Switch">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[645.0, 335.0]">
        </property>
    </entity>
    <entity name="RosPublisher" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10;   exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RosPublisher.js">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="localhost">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[875.0, 335.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RobotCafe" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor reads sensor and location data from a location host&#10; *  &lt;p&gt;&#10; *	The accessor makes REST GET requests to a location host to obtain sensor and location&#10; *	data. The type of data requested is defined by the dataType parameter. Possible values for&#10; *  the dataType parameter are:&#10; *	&quot;ibeacon&quot;: Fetches region UUID, major, minor, range, proximity and RSSI values of&#10; *	nearby iBeacons.&#10; *	&quot;alps&quot;: Fetches ALPS region ID, transmitter IDs, TOA and RSSI values of nearby ALPS&#10; *	transmitters&#10; *	&quot;imu&quot;: Fetches pedometer and heading values&#10; *	&quot;wifi&quot;: Fetches SSIDs, BSSIDs and RSSI values from nearby WiFi hotspots&#10; *	&quot;all&quot;: Fetches all of the above data at once&#10; *	All outputs are JSON formatted and contain UNIX timestamps of when the data was&#10; *	acquired by the location host.&#10; *  @accessor RobotCafe&#10; *&#10;*/&#10;&#10;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('Request', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  }); &#10;  input('External', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  }); &#10;  output('RobotSelection',{'type':'JSON'});&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RobotCafe.js">
        </property>
        <property name="Request" class="ptolemy.actor.parameters.PortParameter" value="&quot;&quot;">
        </property>
        <property name="External" class="ptolemy.actor.parameters.PortParameter" value="&quot;&quot;">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[505.0, 485.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Request" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="External" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="RobotSelection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="UserSelection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="JavaScript2" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;exports.setup = function() {&#10;  input('input');&#10;  output('output');&#10;}&#10;exports.fire = function() {&#10;  var token = get('input');&#10;  //if (token &amp;&amp; token.message) {&#10;    send('message', token.message);&#10;  //}&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="16">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="80">
                </property>
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[740.0, 335.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="script" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="append" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_cardinal" class="ptolemy.kernel.util.StringAttribute" value="SOUTH">
            </property>
        </port>
    </entity>
    <entity name="Hue" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id: Hue.js 231 2015-07-31 22:45:12Z mpanj@seas.upenn.edu $$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/Hue.js">
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.2,0.8,0.0,1.0}">
                </property>
            </property>
        </property>
        <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="&quot;&quot;">
        </property>
        <property name="userName" class="ptolemy.data.expr.StringParameter" value="ptolemyuser">
        </property>
        <property name="lightID" class="ptolemy.actor.parameters.PortParameter" value="1">
        </property>
        <property name="brightness" class="ptolemy.actor.parameters.PortParameter" value="255.0">
        </property>
        <property name="hue" class="ptolemy.actor.parameters.PortParameter" value="65280.0">
        </property>
        <property name="saturation" class="ptolemy.actor.parameters.PortParameter" value="255.0">
        </property>
        <property name="on" class="ptolemy.actor.parameters.PortParameter" value="false">
        </property>
        <property name="transitionTime" class="ptolemy.actor.parameters.PortParameter" value="4">
        </property>
        <property name="trigger" class="ptolemy.actor.parameters.PortParameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1005.0, 440.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="bridgeIPAddress" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="lightID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="brightness" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="hue" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="saturation" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="on" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="transitionTime" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosSubscriber" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor subscribes to a pre-established ROS topic.&lt;br&gt;&#10; *  It communicates to ROS through the rosbridge web socket, and extends the &#10; *  WebSocketClient accessor to do so. &#10; *  It has a 'topic' parameter, that must be prefixed with a '/' eg: '/noise'.&lt;br&gt;. &#10; *  The other parameters configure how the data is to be received according to the rosbridge specification:&#10; *  https://github.com/RobotWebTools/rosbridge_suite/blob/develop/ROSBRIDGE_PROTOCOL.md#344-subscribe&#10; *&#10; *  @accessor RosSubscriber&#10; *  @parameter {string} topic The ROS topic to subscribe to.&#10; *  @parameter {int} throttle_rate The minimum amount of time (in ms) that must elapse between messages sent. Defaults to 0.&#10; *  @parameter {int} queue_length The ROS size of the queue to buffer messages. Messages are buffered as a result of the throttle_rate. Defaults to 1.&#10; *  @parameter {int} fragment_size The maximum size that a message can take before it is to be fragmented. Defaults to 1000. Ptolemy will close the model if fragment size is too large (not sure what the maximum is).&#10; *  @parameter {string} compression A string to specify the compression scheme to be used on messages. Options are &quot;none&quot; (default) and &quot;png&quot;. &#10; *  @output {boolean} connected The status of the web socket connection.&#10; *  @output {JSON} received The data received from the web socket server.&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosSubscriber.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; *&#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs, outputs and parameters from setup() in WebSocketClient.&lt;br&gt;&#10; *  Adds a 'topic' input which is the ROS topic to subscribe to. */&#10;exports.setup = function() {&#10;&#10;   extend('WebSocketClient');&#10;&#10;   parameter('topic', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;   parameter('throttle_rate', {&#10;      type: &quot;int&quot;,&#10;      value: 0&#10;   });&#10;   parameter('queue_length', {&#10;      type: &quot;int&quot;,&#10;      value: 10&#10;   });&#10;   parameter('fragment_size', {&#10;      type: &quot;int&quot;,&#10;      value: 10000&#10;   });&#10;   parameter('compression', {&#10;      type: &quot;string&quot;,&#10;      value: 'none'&#10;   });&#10;   &#10;}&#10;&#10;/** Overrides the toSendInputHandler to throw an error if called. A subscriber should not be publishing inputs. */&#10;exports.toSendInputHandler = function() {&#10;   console.error('This is a subscriber and does not take input to publish.');&#10;}&#10;&#10;/** Inherits initialize from webSocketClient.&lt;br&gt;&#10;    Sends a message to rosbridge to start subscribing to the topic on input 'topic'.*/ &#10;exports.initialize = function() {&#10;  this.ssuper.initialize.apply(this);&#10;&#10;  exports.sendToWebSocket({&#10;      &quot;op&quot;: &quot;subscribe&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;throttle_rate&quot;: getParameter('throttle_rate'),&#10;      &quot;queue_length&quot;: getParameter('queue_length'),&#10;      &quot;fragment_size&quot;: getParameter('fragment_size'),&#10;      &quot;compression&quot;: getParameter('compression')&#10;  });&#10;}&#10;&#10;/** Unsubscribe from the topic. Close websocket connections by calling wrapup of WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unsubscribe = {&#10;      &quot;op&quot;: &quot;unsubscribe&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   }&#10;   exports.sendToWebSocket(unsubscribe);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/RosSubscriber.js">
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.2,0.8,0.0,1.0}">
                </property>
            </property>
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="localhost">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="throttle_rate" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="queue_length" class="ptolemy.data.expr.Parameter" value="10">
        </property>
        <property name="fragment_size" class="ptolemy.data.expr.Parameter" value="10000">
        </property>
        <property name="compression" class="ptolemy.data.expr.StringParameter" value="none">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[875.0, 440.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="PolyPoint" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor reads sensor and location data from a location host&#10; *  &lt;p&gt;&#10; *	The accessor makes REST GET requests to a location host to obtain sensor and location&#10; *	data. The type of data requested is defined by the dataType parameter. Possible values for&#10; *  the dataType parameter are:&#10; *	&quot;ibeacon&quot;: Fetches region UUID, major, minor, range, proximity and RSSI values of&#10; *	nearby iBeacons.&#10; *	&quot;alps&quot;: Fetches ALPS region ID, transmitter IDs, TOA and RSSI values of nearby ALPS&#10; *	transmitters&#10; *	&quot;imu&quot;: Fetches pedometer and heading values&#10; *	&quot;wifi&quot;: Fetches SSIDs, BSSIDs and RSSI values from nearby WiFi hotspots&#10; *	&quot;all&quot;: Fetches all of the above data at once&#10; *	All outputs are JSON formatted and contain UNIX timestamps of when the data was&#10; *	acquired by the location host.&#10; *  @accessor Location&#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var handlers = [];&#10;&#10;&#10;var http = require('httpClient');&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('SensorReading', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  }); &#10;  output('Location',{'type':'JSON'});&#10;}&#10;/* Initialize connection.*/&#10;exports.initialize = function() {&#10;   var ipAddress = get('HostIP');&#10;   var port = get('HostPort');&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the localization host.&quot;;&#10;   }&#10;    if (port == null || port.trim() == &quot;&quot;) {&#10;      throw &quot;No Port is given for the localization host.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;:&quot; + port;  &#10;   handle = addInputHandler('dataType', getData);&#10;}&#10;&#10;/* Get data over REST based on dataType input */&#10;function getData(){&#10;	var type = get('dataType');&#10;	switch(type){&#10;		case &quot;ibeacon&quot;:&#10;&#10;&#10;      http.get(url+'/ibeacon', function (request) {&#10;        send('iBeacon', request.body);&#10;      });&#10;&#10;&#10;			// send('iBeacon', httpRequest(url + &quot;/ibeacon&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;alps&quot;:&#10;			send('ALPS', httpRequest(url  + &quot;/alps&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;imu&quot;:&#10;			send('IMU', httpRequest(url  + &quot;/imu&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;wifi&quot;:&#10;			send('WiFi', httpRequest(url  + &quot;/wifi&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;location&quot;:&#10;			send('Location', httpRequest(url  + &quot;/location&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;			break;&#10;		case &quot;all&quot;:&#10;			getAll();&#10;			break;&#10;		default:&#10;			getAll();&#10;	}&#10;}&#10;&#10;/* Get all location/sensor data */&#10;function getAll() {&#10;   	send('iBeacon', httpRequest(url + &quot;/ibeacon&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('ALPS', httpRequest(url  + &quot;/alps&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('IMU', httpRequest(url  + &quot;/imu&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('WiFi', httpRequest(url  + &quot;/wifi&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;   	send('Location', httpRequest(url  + &quot;/location&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;}&#10;	&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/bradjc/svn/accessors/web/Location.js">
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.2,0.8,0.0,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="text" class="ptolemy.kernel.util.StringAttribute" value="♕">
                </property>
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[530.0, 260.0]">
        </property>
        <property name="SensorReading" class="ptolemy.actor.parameters.PortParameter" value="&quot;&quot;">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="SensorReading" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Location" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[600.0, 335.0]">
        </vertex>
    </relation>
    <link port="WebSocketServer.received" relation="relation"/>
    <link port="JavaScript.message" relation="relation2"/>
    <link port="JavaScript.input" relation="relation"/>
    <link port="WebSocketServer2.received" relation="relation7"/>
    <link port="Location.Location" relation="relation5"/>
    <link port="Location.SensorReading" relation="relation2"/>
    <link port="Switch.input" relation="relation5"/>
    <link port="Switch.output" relation="relation6"/>
    <link port="Switch.control" relation="relation8"/>
    <link port="RosPublisher.toSend" relation="relation10"/>
    <link port="RobotCafe.Request" relation="relation7"/>
    <link port="RobotCafe.RobotSelection" relation="relation8"/>
    <link port="RobotCafe.UserSelection" relation="relation9"/>
    <link port="JavaScript2.input" relation="relation6"/>
    <link port="JavaScript2.output" relation="relation10"/>
    <link port="JavaScript2.append" relation="relation9"/>
    <link port="Hue.hue" relation="relation4"/>
    <link port="RosSubscriber.received" relation="relation4"/>
    <link port="PolyPoint.Location" relation="relation5"/>
</entity>
